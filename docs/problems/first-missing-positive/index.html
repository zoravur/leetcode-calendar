<!DOCTYPE html><html lang="en"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet"><title>first-missing-positive | Zoravur&#39;s LeetCode Calendar</title><script>
      // Set initial theme before page renders to prevent flash
      const theme = localStorage.getItem('theme') || 'dark';
      document.documentElement.setAttribute('data-theme', theme);
    </script><link rel="stylesheet" href="/leetcode-calendar/assets/index.BmmUQ6-S.css">
<style>pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}/*!
  Theme: GitHub Dark
  Description: Dark theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/.hljs{color:#c9d1d9;background:#0d1117}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#ff7b72}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#d2a8ff}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-variable,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id{color:#79c0ff}.hljs-regexp,.hljs-string,.hljs-meta .hljs-string{color:#a5d6ff}.hljs-built_in,.hljs-symbol{color:#ffa657}.hljs-comment,.hljs-code,.hljs-formula{color:#8b949e}.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo{color:#7ee787}.hljs-subst{color:#c9d1d9}.hljs-section{color:#1f6feb;font-weight:700}.hljs-bullet{color:#f2cc60}.hljs-emphasis{color:#c9d1d9;font-style:italic}.hljs-strong{color:#c9d1d9;font-weight:700}.hljs-addition{color:#aff5b4;background-color:#033a16}.hljs-deletion{color:#ffdcd7;background-color:#67060c}
</style></head> <body data-theme="dark"> <div class="app">  <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="BmIsj" prefix="r1" component-url="/leetcode-calendar/assets/ProblemDetail.Cb6K2Sey.js" component-export="default" renderer-url="/leetcode-calendar/assets/client.nc8uITnr.js" props="{&quot;problems&quot;:[1,[[0,{&quot;slug&quot;:[0,&quot;add-binary&quot;],&quot;date&quot;:[0,&quot;2026-02-22&quot;],&quot;problem&quot;:[0,&quot;add-binary&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;easy&quot;],&quot;time_minutes&quot;:[0,4],&quot;topics&quot;:[1,[[0,&quot;binary&quot;],[0,&quot;addition&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;Add two binary strings together.\n\n## Approach\n\nFairly straightforward additional algorithm -- mod addition and carry. Easy one to get back into the\nflow.\n\n## Solution\n\n```python\nclass Solution:\n    def addBinary(self, a: str, b: str) -&gt; str:\n        a = &#39;0&#39; * (max(len(a), len(b)) - len(a)) + a\n        b = &#39;0&#39; * (max(len(a), len(b)) - len(b)) + b\n\n        result = []\n        carry = 0\n        for d1, d2 in zip(a[::-1], b[::-1]):\n            total = int(d1) + int(d2) + carry\n            if total &gt;= 2:\n                total -= 2\n                carry = 1\n            else:\n                carry = 0\n            result.append(total)\n        if carry:\n            result.append(carry)\n        \n        return &#39;&#39;.join(str(d) for d in result[::-1])\n\n```\n\n## Complexity\n\n* Time: O(n)\n* Space: O(n)\n\n## Results\n\n28ms, 7.9MB\n\n## Next Steps\n\nI could spend more time making my code neater.\n\n## Notes\n\nN/A\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;coin-change-ii&quot;],&quot;date&quot;:[0,&quot;2026-02-20&quot;],&quot;problem&quot;:[0,&quot;coin-change-ii&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,25],&quot;topics&quot;:[1,[[0,&quot;dynamic-programmnig&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;You are given an integer array coins representing coins of different denominations (e.g. 1 dollar, 5 dollars, etc) and an integer amount representing a target amount of money.\n\nReturn the number of distinct combinations that total up to amount. If it&#39;s impossible to make up the amount, return 0.\n\nYou may assume that you have an unlimited number of each coin and that each value in coins is unique.\n\n## Approach\n\nThe approach I used was to use DP. My initial attempt was top-down, but that ran into space\nrequirements so I switched to bottom-up. With bottom-up the approach was fairly simple, although\nI did originally make the mistake of counting permutations. The key is to realize that once\nyou stop adding a coin, you can&#39;t go back to it, as that would generate a permutation (addition order)\nthat is not sorted in the initial order of the coins. By always maintaining sorted order, we don&#39;t\nhave to deduplicate, and simply never generate duplicate permutations in the first place.\n\nThen the DP was straightforward. In fact, it&#39;s kind of like a Dyck path -- at each step, take one\nstep to the right (change coin denomination) or take one step up (add one more of the current coin).\nPath counting the Dyck paths is all we need to generate our solution.\n\n## Solution\n\n```python\nclass Solution:\n    def change(self, amount: int, coins: List[int]) -&gt; int:\n        # It seems like DP would be our approach here -- feels pascal-triangles / \n        # path-counting ish.\n        # so, basically the problem is, how many coins does it take to make target\n        # t? well that&#39;s just \n\n        # result = sum[change(t - coin) for coin in coins]\n        # with base case 0 if t &lt; 0 (or 1 if t == 0).\n\n        # top down dp would be fastest atp.\n\n        # import functools\n\n        # @functools.cache\n        # def change_rec(t, k):\n        #     if t &lt; 0:\n        #         return 0\n        #     if t == 0:\n        #         return 1\n        #     total = sum(change_rec(t - coins[i], i+1) for i in range(k))\n        #     # print(t, total)\n        #     return total\n\n        # return change_rec(amount, len(coins))\n\n        # getting stack overflow issues, whcih is surprising\n        # whatever, bottom up dp it is\n\n        dp = [[1] + [0] * amount for _ in range(len(coins))]\n\n        for t in range(1, amount+1):\n            for i in range(len(coins)):\n                dp[i][t] = dp[i-1][t]\n                if t-coins[i] &gt;= 0:\n                    dp[i][t] += dp[i][t-coins[i]]\n        # print(dp)\n        return dp[-1][amount]\n\n\n```\n\n## Complexity\n\n* Time: O(n \\* k) -- n is the amount, and is the number of coins\n* Space: O(n \\* k) additional -- as above\n\n## Results\n\n60ms, 8.8MB\n\n## Next Steps\n\nI could try implementing a more optimal solution -- DP problems that depend only on the previous row\nis a good heuristic for getting memory down.\n\n## Notes\n\nSee solution.\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;foreign-dictionary&quot;],&quot;date&quot;:[0,&quot;2026-02-19&quot;],&quot;problem&quot;:[0,&quot;foreign-dictionary&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;hard&quot;],&quot;time_minutes&quot;:[0,56],&quot;topics&quot;:[1,[[0,&quot;lexicographic-ordering&quot;],[0,&quot;topological-sort&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nThe approach here is to first determine a partial order based on the items in the dictionary.\nObviously, the orders in which the first letter of each word appears corresponds to the order of\nthe dictionary. Similarly, at each level, we group the words by common prefix up to i, and then\ncompare the i&#39;th letter. This way, we generate every implied order in the dictionary.\n\nWe take each ordering implied by the dictionary (call it a chain), and generate a dependency graph\nfrom it. This can then be used in a standard topological sort, which will tell us a candidate\nordering.\n\nLastly, we verify the ordering, because the solution that I came up with will generate an invalid\norder if the test case is invalid. A quick and dirty way to do this is to verify the candidate\nordering again. If the validation fails, there must not be any valid ordering, because the algorithm\nis guaranteed to generate a valid one if it exists.\n\n## Solution\n\n```python\nclass Solution:\n    def foreignDictionary(self, words: List[str]) -&gt; str:\n        # Can determine partial order by bucketing words\n        # Can determine candidate total order through topological sort I think\n\n        # Topological sorts work only on DAGs\n\n        # It makes sense that we should have a DAG after order determining.\n\n        nested = lambda: defaultdict(nested)\n\n        d = nested()\n\n        for word in words:\n            cur = d\n            for c in word:\n                if c in cur:\n                    if c != cur[&#39;last&#39;]:\n                        return &#39;&#39;\n                cur[&#39;last&#39;] = c\n                cur = cur[c]\n\n        dicts = [d]\n\n        chains = []\n        while len(dicts) &gt; 0:\n            new_dicts = []\n            for cur in dicts:\n                chain = [k for k in cur if k != &#39;last&#39;]\n                new_dicts.extend(cur[k] for k in chain)\n                chains.append(chain)\n            dicts = new_dicts\n\n        # print(chains)\n\n        g = defaultdict(list)\n\n        for chain in chains:\n            for node in chain:\n                g[node]\n            for s, e in zip(chain, chain[1:]):\n                g[e].append(s)\n\n        # print(g)\n        \n        # g (our graph. Time to topo-sort)\n        result = []\n\n        visited = set()\n        def dfs(node, iteration=0):\n            if node in visited:\n                return\n            visited.add(node)\n            for adj in g[node]:\n                dfs(adj, iteration)\n            result.append(node)\n\n        for node in list(g.keys()):\n            dfs(node)\n\n        # copy pasted from verify alien dict\n        order = {c: i for i, c in enumerate(result)}\n        \n        for w1, w2 in zip(words, words[1:]):\n            for c1, c2 in zip(w1, w2):\n                if order[c1] &gt; order[c2]:\n                    return &#39;&#39;\n                elif order[c1] &lt; order[c2]:\n                    break\n            else:\n                if len(w1) &gt; len(w2):\n                    return &#39;&#39;\n\n        return &#39;&#39;.join(result)\n\n```\n\n## Complexity\n\n* Time: O(n\\*m), where n, m are the number and length of words, respectively\n* Space: O(n)\n\n## Results\n\n\\[Add performance metrics here, or N/A if not applicable]\n\n## Next Steps\n\nSolution is quite slow, could be significantly faster\n\n## Notes\n\nSee solution\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;plus-one&quot;],&quot;date&quot;:[0,&quot;2026-02-19&quot;],&quot;problem&quot;:[0,&quot;plus-one&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;easy&quot;],&quot;time_minutes&quot;:[0,5],&quot;topics&quot;:[1,[[0,&quot;array&quot;],[0,&quot;math&quot;],[0,&quot;addition&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;You are given an integer array digits, where each digits\\[i] is the ith digit of a large integer. It is ordered from most significant to least significant digit, and it will not contain any leading zero.\n\nReturn the digits of the given integer after incrementing it by one.\n\n## Approach\n\nWe simulate the addition operation (ripple carry).\n\n## Solution\n\n```python\nclass Solution:\n    def plusOne(self, digits: List[int]) -&gt; List[int]:\n        carry = 1\n        i = len(digits) - 1\n        while i &gt;= 0:\n            digits[i] += carry\n            carry = 0\n            if digits[i] == 10:\n                digits[i] = 0\n                carry = 1\n            i -= 1\n            if carry == 0:\n                break\n        else:\n            digits = [1] + digits\n\n        return digits\n\n```\n\n## Complexity\n\n* Time: O(n)\n* Space: O(1) additional\n\n## Results\n\n28ms, 7.9MB\n\n## Next Steps\n\nThe code could be significantly cleaner.\n\n## Notes\n\nN/A\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;jump-game-ii&quot;],&quot;date&quot;:[0,&quot;2026-02-16&quot;],&quot;problem&quot;:[0,&quot;jump-game-ii&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,10],&quot;topics&quot;:[1,[[0,&quot;array&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;You are given an array of integers nums, where nums\\[i] represents the maximum length of a jump towards the right from index i. For example, if you are at nums\\[i], you can jump to any index i + j where:\n\n* j &lt;= nums\\[i]\n* i + j &lt; nums.length\n* You are initially positioned at nums\\[0].\n\nReturn the minimum number of jumps to reach the last position in the array (index nums.length - 1). You may assume there is always a valid answer.\n\n## Approach\n\nI pretty much went with a DP approach. It is O(n \\* m), where n is the\nnumber of cells, and m is the max jump distance.\n\n## Solution\n\n```python\nclass Solution:\n    def jump(self, nums: List[int]) -&gt; int:\n        dp = [0] + [float(&#39;inf&#39;)] * (len(nums) - 1)\n        for i in range(len(nums)):\n            for j in range(min(nums[i]+1, len(nums)-i)):\n                dp[i+j] = min(dp[i] + 1, dp[i+j])\n        # print(dp)\n        return dp[-1]\n\n```\n\n## Complexity\n\n* Time: O(n\\*m)\n* Space: O(n)\n\n## Results\n\n29ms, 7.8MB\n\n## Next Steps\n\nCould be improved by using a min-max window, according to the solution.\nI guess this would work, because if index k is reachable, k-1 is\nreachable as well, because whichever step reaches k from an index\nbefore k, that starting position can also reach k - 1. This is\nsuffficient to realize an optimal solution.\n\nAll you would have to do, is whenever you extend a window, check the\nfurthest reachable cells by iterating through the cells which have been\nadded.\n\nEasy money.\n\n## Notes\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;partition-to-k-equal-sum-subsets&quot;],&quot;date&quot;:[0,&quot;2026-02-11&quot;],&quot;problem&quot;:[0,&quot;partition-to-k-equal-sum-subsets&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,0],&quot;topics&quot;:[1,[[0,&quot;backtracking&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nBacktracking approach. No real method, besides the fact that I remove elements from the array\nwhen the partition is found.\n\n## Solution\n\n```python\nclass Solution:\n    def canPartitionKSubsets(self, nums: List[int], k: int) -&gt; bool:\n        # first, sum(nums) and k together determine the target for each subset.\n        # second, it&#39;s a matter of hitting the target sum(nums) / k.\n\n        # Honestly, if we could do this is linear time I&#39;d be very impressed.\n        # nlogn is pretty much the next best thing, which is equivalent to sorting \n        # in any case. And once we&#39;ve sorted,\n\n        # wait a second, even if we did sort, two pointers approach wouldn&#39;t work here.\n        \n        # It&#39;s kind of like two-sum, honestly. \n\n        # And why is the frequency of each element no more than 4? \n        # And why is nums.length only 16? Maybe we need to backtrack?\n\n        # Let&#39;s try backtracking first, at least.\n\n        if sum(nums) % k != 0:\n            return False\n        target = sum(nums) / k\n        \n        def recPartition(nums, i, k):\n            if k == 0:\n                # print(\&quot;Found partition\&quot;)\n                return []\n            if i == len(nums) or k &lt; 0:\n                return None\n\n            res = recPartition(nums, i+1, k-nums[i])\n            if res is not None:\n                res.append(i)\n                return res\n            res = recPartition(nums, i+1, k)\n            if res is not None:\n                return res\n            return None\n\n        for _ in range(k-1):\n            partition = recPartition(nums, 0, target)\n            if partition is None:\n                return False\n            nums = [num for i, num in enumerate(nums) if i not in partition]\n\n        return True\n\n```\n\n## Complexity\n\n* Time: O(2^n)\n* Space: O(n)\n\n## Results\n\n27ms, 7.9MB\n\n## Next Steps\n\nLess memory hungry, check test cases better -- one large test case (bounds) is useful.\n\n## Notes\n\nSee solution.\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;meeting-schedule&quot;],&quot;date&quot;:[0,&quot;2026-02-10&quot;],&quot;problem&quot;:[0,&quot;meeting-schedule&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;easy&quot;],&quot;time_minutes&quot;:[0,10],&quot;topics&quot;:[1,[[0,&quot;intervals&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nSort intervals and check if end of previous meeting ever exceeds start of next.\n\n## Solution\n\n```python\n\&quot;\&quot;\&quot;\nDefinition of Interval:\nclass Interval(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\&quot;\&quot;\&quot;\n\nclass Solution:\n    def canAttendMeetings(self, intervals: List[Interval]) -&gt; bool:\n        # Okay, we have a bunch of intervals.\n        # How can we determine if any two intervals overlap?\n        # What if we had a single array, of start and end times,\n        # annotated with START or END? Then if there&#39;s ever two consecutive starts,\n        # that means it&#39;s over.\n\n        # Okay, I checked the recommended complexity -- nlogn n, which is exactly what I\n        # expected for my solution. Time to implement.\n\n        # for inter in intervals:\n        #     start, end = inter.start, inter.end\n            \n        # Wait, we can literally just sort? Using a priority queue doesn&#39;t change the\n        # complexity at all.\n\n        intervals = [(inter.start, inter.end) for inter in intervals]\n\n        intervals.sort()\n        for (_, end), (start, _) in zip(intervals, intervals[1:]):\n            if end &gt; start:\n                return False\n        return True\n\n        # Okay, now I can probably do some test cases.\n        # First of all, let&#39;s check the examples.\n        # Test case: touching\n        # Test case: test case, same start, different end\n\n        # Okay, it all passed. Time to submit.\n\n\n```\n\n## Complexity\n\n* Time: O(nlogn)\n* Space: O(n)\n\n## Results\n\n28ms (100%), 7.9MB (97.50%) -- judge is a bit weird though\n\n## Next Steps\n\nOne-shotted this one. I could start using the stopwatch / timer and calculate times more precisely.\n\n## Notes\n\nSee solution\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;longest-repeating-substring-with-replacement&quot;],&quot;date&quot;:[0,&quot;2026-02-09&quot;],&quot;problem&quot;:[0,&quot;longest-repeating-substring-with-replacement&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,30],&quot;topics&quot;:[1,[[0,&quot;sliding-window&quot;],[0,&quot;hash-map&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;You are given a string s consisting of only uppercase english characters and an integer k. You can choose up to k characters of the string and replace them with any other uppercase English character.\n\nAfter performing at most k replacements, return the length of the longest substring which contains only one distinct character.\n\n## Approach\n\nSliding window. The core realization is that a window is valid if difference between the frequency\nof the most frequent character and the size of the window is less than or equal to k. Therefore,\nall we need to do is grow the window until the first point that the window is invalid. After that,\nwe shrink the window by increasing the left pointer (i). This will iterate through the largest\npossible window covering each index. At every iteration, we also must check if the current window\nsize is greater than the greatest size seen so far.\n\nI missed one optimization which actually changes the complexity -- I will discuss that in next steps.\n\n## Solution\n\n```python\nclass Solution:\n    def characterReplacement(self, s: str, k: int) -&gt; int:\n        i = 0\n        j = 0\n        cnt = collections.defaultdict(int)\n\n        maxi = 0\n        while j &lt; len(s):\n            j += 1\n            l = j - i\n            cnt[s[j-1]] += 1\n            ch = max(cnt, key=cnt.get)\n            if l - cnt[ch] &gt; k:\n                i += 1\n                cnt[s[i-1]] -= 1\n                l -= 1\n            maxi = max(maxi, l)\n        return maxi\n\n```\n\n## Complexity\n\n* Time: O(nk)\n* Space: O(k)\n\n## Results\n\n28ms (100%), 7.8MB (100%)\n\n## Next Steps\n\nNotice the extra k factor in the time complexity. This can be reduced by realizing that the maximum\nseen window size is simply k + the frequency of the most frequent element. Therefore, we can\nmonotonically check if the current frequency of the added character is larger than the largest.\nEven if the frequency drops below the highest seen frequency, the fact that the previous window is\nlarger than the current window guarantees that the maximum will not be affected. Only when we see\na new, higher max frequency do we need to update our result, which is precisely when the maximum\nfrequency increases.\n\n## Notes\n\nN/A\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;evaluate-reverse-polish-notation&quot;],&quot;date&quot;:[0,&quot;2026-02-08&quot;],&quot;problem&quot;:[0,&quot;evaluate-reverse-polish-notation&quot;],&quot;source&quot;:[0,&quot;leetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,25],&quot;topics&quot;:[1,[[0,&quot;stack&quot;],[0,&quot;arithmetic&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;You are given an array of strings tokens that represents a valid arithmetic expression in Reverse Polish Notation.\n\nReturn the integer that represents the evaluation of the expression.\n\n* The operands may be integers or the results of other operations.\n* The operators include &#39;+&#39;, &#39;-&#39;, &#39;\\*&#39;, and &#39;/&#39;.\n* Assume that division between integers always truncates toward zero.\n\n## Approach\n\nReverse Polish Notation is easily evaluable using a stack approach. The rightmost argument is on the\ntop of the stack, and the argument to its left is the second highest item on the stack. When we\nencounter an op, RPN assumes that the op applies to the rightmost two arguments. Therefore, all\nwe need to do is pop the top two elements as arguments, and apply the op, and push the result back\non to the stack.\n\nThe only intricacies are 1) op order, as some operands are not commutative, and 2) a quirk of Python\nthat the integer division operator rounds towards negative infinity instead of truncating toward 0.\nAs long as you keep in mind that the first pop is the right element, and that int(a / b) is the\nidiomatic way to do a truncating division, you should be fine.\n\n## Solution\n\n```python\nclass Solution:\n    def evalRPN(self, tokens: List[str]) -&gt; int:\n        stack = []\n        for token in tokens:\n            match token:\n                case &#39;+&#39;:\n                    b, a = stack.pop(), stack.pop()\n                    stack.append(a + b)\n                case &#39;-&#39;:\n                    b, a = stack.pop(), stack.pop()\n                    stack.append(a - b)\n                case &#39;*&#39;:\n                    b, a = stack.pop(), stack.pop()\n                    stack.append(a * b)\n                case &#39;/&#39;:\n                    b, a = stack.pop(), stack.pop()\n                    stack.append(int(a / b))\n                case _:\n                    stack.append(int(token))\n        return stack[-1]\n\n```\n\n## Complexity\n\n* Time: O(n)\n* Space: O(n)\n\n## Results\n\n30ms (100%), 7.9MB (100%)\n\n## Next Steps\n\nRemember the truncation thing. That threw me off majorly.\n\n## Notes\n\nN/A\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;excel-sheet-column-title&quot;],&quot;date&quot;:[0,&quot;2026-02-06&quot;],&quot;problem&quot;:[0,&quot;excel-sheet-column-title&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,30],&quot;topics&quot;:[1,[[0,&quot;modulus&quot;],[0,&quot;base-conversion&quot;],[0,&quot;ascii&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nI had two incorrect submissions before the correct one, and many, many failed test\ncases. I&#39;m not sure I&#39;m qualified to explain the solution I pretty much found\nby trial and error. The idea is just to notice that to compute digits, we&#39;re\nbasically trying to find a number in base 26, except for the fact that the 26th\nnumber (which normally corresponds to \&quot;10\&quot;, actually corresponds to \&quot;Z\&quot; (single digit), and there is no analog for 0. Basically, the way I solved this, is instead of\nhaving a \&quot;0\&quot; digit in case the modulus was equal to 0, I actually had a special\ncase which would take off an additional 26 in order to create a 0 digit. This way,\nwe rolled over at 27 (which is what we want) instead of 26. This way, we actually\nnever return \&quot;0\&quot; as a digit, and this is evidenced by the fact that ord(&#39;A&#39;) has 1\nsubtracted from it -- if d were 0 then we would get the ascii character before &#39;A&#39;\nwhich is not a letter at all.\n\n## Solution\n\n```python\nclass Solution:\n    def convertToTitle(self, columnNumber: int) -&gt; str:\n        digits = []\n\n        while columnNumber &gt; 0:\n            if columnNumber % 26 == 0:\n                digits.append(26)\n                columnNumber = (columnNumber - 1) // 26\n            else:\n                digit, columnNumber = (columnNumber) % 26, (columnNumber) // 26\n                digits.append(digit)\n\n\n        print(digits)\n        return &#39;&#39;.join(chr(d + ord(&#39;A&#39;)-1) for d in digits[::-1])\n\n```\n\n## Complexity\n\n* Time: O(log n) (base 26!)\n* Space: O(log n)\n\n## Results\n\n27ms (100%), 7.7MB (99.39%)\n\n## Next Steps\n\nI will need to resolve this to get a better understanding of it.\n\n## Notes\n\nN/A\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;invert-a-binary-tree&quot;],&quot;date&quot;:[0,&quot;2026-02-05&quot;],&quot;problem&quot;:[0,&quot;invert-a-binary-tree&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,3],&quot;topics&quot;:[1,[[0,&quot;binary-tree&quot;],[0,&quot;recursion&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nJust do it! INVERT!\n\n## Solution\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n        if not root:\n            return root\n        root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)\n        return root\n\n```\n\n## Complexity\n\n* Time: O(n)\n* Space: O(1)\n\n## Results\n\n27ms (100%), 8.0MB (98.38%)\n\n## Next Steps\n\nInvert moar\n\n## Notes\n\nN/A\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;time-based-key-value-store&quot;],&quot;date&quot;:[0,&quot;2026-02-05&quot;],&quot;problem&quot;:[0,&quot;time-based-key-value-store&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,0],&quot;topics&quot;:[1,[[0,&quot;array&quot;],[0,&quot;binary-search&quot;],[0,&quot;dictionary&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;Implement a time-based key-value data structure that supports:\n\n* Storing multiple values for the same key at specified time stamps\n* Retrieving the key&#39;s value at a specified timestamp\n\nImplement the TimeMap class:\n\n* TimeMap() Initializes the object.\n* void set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp.\n* String get(String key, int timestamp) Returns the most recent value of key if set was previously called on it and the most recent timestamp for that key prev\\_timestamp is less than or equal to the given timestamp (prev\\_timestamp &lt;= timestamp). If there are no values, it returns \&quot;\&quot;.\n\nNote: For all calls to set, the timestamps are in strictly increasing order.\n\n## Approach\n\nFairly straightforward, especially because O(log n) for lookup is permissible, and\nbecause timestamps are in strictly increasing order.\n\nAll we have to do is store the timestamp associated with each value, and that\nbecomes a sequence. When get is called, we just binary search the timestamps.\n\nBecause the timestamps are nondecreasing (actually, increasing), it&#39;s guaranteed\nthat each subarray is sorted.\n\n## Solution\n\n```python\nimport bisect\n\nclass TimeMap:\n    def __init__(self):\n        self.d = collections.defaultdict(list)\n\n    def set(self, key: str, value: str, timestamp: int) -&gt; None:\n        self.d[key].append((timestamp, value))\n\n    def get(self, key: str, timestamp: int) -&gt; str:\n        arr = self.d[key]\n        idx = bisect.bisect_right(arr, timestamp, key=lambda x: x[0])\n        if idx-1 &gt;= 0:\n            return arr[idx-1][1]\n        return \&quot;\&quot;\n\n```\n\n## Complexity\n\n* Time: O(1) (set), O(log n) (get)\n* Space: O(n) (where n is the total number of elements in the data structure)\n\n## Results\n\n33ms (100%), 7.9MB (100%)\n\n## Next Steps\n\nCould stand to read the function signatures more carefully -- I missed that the\ndefault return should be an empty string, not null.\n\n## Notes\n\nN/A\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;transpose-matrix&quot;],&quot;date&quot;:[0,&quot;2026-02-05&quot;],&quot;problem&quot;:[0,&quot;transpose-matrix&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;easy&quot;],&quot;time_minutes&quot;:[0,1],&quot;topics&quot;:[1,[[0,&quot;implementation&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nHow does the solution work? Let&#39;s step through:\n\n```\nmatrix -&gt; [[1,2],[3,4]]\nzip(*matrix) -&gt; zip([1, 2], [3, 4])\nlist(zip(*matrix)) -&gt; ([(1, 3), (2, 4)]\n```\n\nThis solution relies on the fact that zip accepts any number of arguments, and hence as many as the number of columns in the\nmatrix.\n\nWe convert to a list so that it doesn&#39;t return a generator. However, this returns a list of tuples (technically wrong).\n\nIf we strictly care about returning a list of lists, we must do `[list(r) for r in zip(*matrix)]`.\n\n## Solution\n\n```python\nclass Solution:\n    def transpose(self, matrix: List[List[int]]) -&gt; List[List[int]]:\n        return list(zip(*matrix))\n\n```\n\n## Complexity\n\n* Time: O(n\\*m)\n* Space: O(n\\*m) -- building up a new matrix\n\n## Results\n\n27ms (100%), 7.9MB (96.56%)\n\n## Next Steps\n\nSomething ergonomic for in-place too?\n\n## Notes\n\nN/A\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;verifying-an-alien-dictionary&quot;],&quot;date&quot;:[0,&quot;2026-02-05&quot;],&quot;problem&quot;:[0,&quot;verifying-an-alien-dictionary&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,7],&quot;topics&quot;:[1,[[0,&quot;lexicographic-ordering&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.\n\nGiven a sequence of words written in the alien language, and the order of the alphabets, return true if and only if the given words are sorted lexicographically in this alien language.\n\n## Approach\n\nIf you know how to sort lexicographically, you know how to check if two items are sorted. The only thing weird about this is the different ordering of the characters, but, but if you replace the key from being the char itself (which compares based\non ascii) with the index in the order list, the problem reduces to verifying a sort.\n\n## Solution\n\n```python\nclass Solution:\n    def isAlienSorted(self, words: List[str], order: str) -&gt; bool:\n        order = {c: i for i, c in enumerate(order)}\n        \n        for w1, w2 in zip(words, words[1:]):\n            for c1, c2 in zip(w1, w2):\n                if order[c1] &gt; order[c2]:\n                    return False\n                elif order[c1] &lt; order[c2]:\n                    break\n            else:\n                if len(w1) &gt; len(w2):\n                    return False\n\n        return True\n\n```\n\n## Complexity\n\n* Time: O(n), where n is the length of the input in bytes\n* Space: O(1), because the dictionary is always 26 letters.\n\n## Results\n\n28ms (100%), 7.7MB (100%)\n\n## Next Steps\n\nNone.\n\n## Notes\n\nN/A\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;minimum-stack&quot;],&quot;date&quot;:[0,&quot;2026-02-04&quot;],&quot;problem&quot;:[0,&quot;minimum-stack&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,5],&quot;topics&quot;:[1,[[0,&quot;stack&quot;],[0,&quot;data-structure&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;Design a stack class that supports the push, pop, top, and getMin operations.\n\nMinStack() initializes the stack object.\n\nvoid push(int val) pushes the element val onto the stack.\n\nvoid pop() removes the element on the top of the stack.\n\nint top() gets the top element of the stack.\n\nint getMin() retrieves the minimum element in the stack.\n\nEach function should run in O(1) time.\n\n## Approach\n\nYou have to keep track of the minimum at all times, and the minimum is computed\nto be the minimum of all the elements currently in the stack. The key is realizing\nwe don&#39;t need a heap or anything like that because we never actually have to remove\nthe smallest element. It&#39;s just a matter of dynamically updating the smallest\nvalue. This is easy to compute inductively when growing the stack -- the min of\nthe arr\\[1..n] is just min(arr\\[1..n-1], arr\\[n]). \&quot;Undoing\&quot; a min operation, however,\nis impossible because it destroys the information of its larger argument. Therefore, we must store what the minimum was at each step. This whole thing works because\nthe elements come out in LIFO order -- it&#39;s guaranteed that self.mini\\[i-1] is always\nthe minimum of self.stack\\[0..i].\n\n## Solution\n\n```python\nclass MinStack:\n    def __init__(self):\n        self.mini = []\n        self.stack = []\n\n    def push(self, val: int) -&gt; None:\n        if len(self.mini) == 0:\n            self.mini.append(val)\n            self.stack.append(val)\n            return\n        self.mini.append(min(val, self.mini[-1]))\n        self.stack.append(val)\n        \n\n    def pop(self) -&gt; None:\n        self.mini.pop()\n        self.stack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1]\n\n    def getMin(self) -&gt; int:\n        return self.mini[-1]\n\n```\n\n## Complexity\n\n* Time: O(1)\n* Space: O(n)\n\n## Results\n\n29ms (100%), 7.7MB (100%).\n\n## Next Steps\n\nNone here -- I pretty much nailed this one first try.\n\n## Notes\n\nN/A\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;majority-element-ii&quot;],&quot;date&quot;:[0,&quot;2026-02-03&quot;],&quot;problem&quot;:[0,&quot;majority-element-ii&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,54],&quot;topics&quot;:[1,[[0,&quot;array&quot;],[0,&quot;hash-map&quot;],[0,&quot;counting&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Problem\n\nYou are given an integer array nums of size n, find all elements that appear more than ⌊ n/3 ⌋ times. You can return the result in any order.\n\n## Approach\n\nThis one was kinda hard and ad-hoc. I had one failed submission. I don&#39;t know how I would explain\nhow I did this beyond acknowledging that it&#39;s a balance problem. The elements which appear\nmore than a third of the time necessarily dominate all the other elements. The size of the hashmap\nactually compensates for the reduced frequency of each individual element.\n\n## Solution\n\n```python\nclass Solution:\n    def majorityElement(self, nums: List[int]) -&gt; List[int]:\n        result = []\n        counts = []\n\n        for num in nums:\n            try:\n                idx = result.index(num)\n                counts[idx] += 2\n            except ValueError:\n                if len(result) &lt; 3:\n                    result.append(num)\n                    counts.append(2)\n                else: \n                    # element not in list\n                    for idx in range(len(counts)-1, -1, -1):\n                        counts[idx] -= 1\n                        if counts[idx] == 0:\n                            result = result[:idx] + result[idx+1:]\n                            counts = counts[:idx] + counts[idx+1:]\n\n        candidates = [result[i] for i in range(len(counts)) if counts[i] &gt;= 2]\n\n        d = {c: 0 for c in candidates}\n\n        for num in nums:\n            if num in d:\n                d[num] += 1\n        return [num for num in d if d[num] &gt; math.floor(len(nums) / 3)]\n\n\n\n```\n\n## Complexity\n\n* Time: O(n)\n* Space: O(1)\n\n## Results\n\n* 58ms (100%)\n* 9.2MB (100%)\n\n## Next Steps\n\nMemorize the solution. I honestly don&#39;t see a better way of doing this.\nI guess I could spend more time refining my implementations. I usually stop after test cases pass.\n1 failed attempt.\n\n## Notes\n\n```\n# Start time: 8:12AM\n# Finish time: 9:06AM\n\n# seems like a \&quot;balance\&quot; problem.\n# because greater than a third is a sufficiently high fraction to be suspicious.\n# What would we do if we had to find all elements that appear more than \n# half the time?\n\n# If any element appears more than half the time, it is sufficient to \&quot;annihilate\&quot;\n# all other elements. So the question becomes, if we have a candidate, like\n# [3,4,2,2,2]\n# or \n# [2,2,3,4,2]\n# Is it possible to make it so that each of the twos, \&quot;annihilate\&quot; all the others?\n# If we stored a \&quot;candidateNum\&quot;, and \&quot;balance\&quot; (AND \&quot;total_seen\&quot;), we can determine\n# whether the current most seen element represents a balance greater than a half.\n\n# I&#39;ve convinced myself that a solution is possible.\n\n# Now, how would things change for the three case?\n# Well, there are three real cases; we need an algorithm for all 3:\n# 1) No dominant element\n#   - Come back to this\n# 2) One dominant element \n#   - Has to appear with fraction greater than 1/3rd.\n#   - If we always remove from the smaller element, then the 2nd and 3rd 3rd \n#     annihilate each other, leaving the first third full.\n#   - What happens if there were really 2 dominant elements?\n# 3) Two dominant elements\n#   - Well, in that case, 2 alone is sufficient to overpower the rest, _provided_\n#       1 really does dominate the rest of the elements.\n\n# Regarding the no dominant element case:\n# If we always eliminate from the smaller candidate, protecting the other, it&#39;s possible for \n# something not representing a 1/3rd fraction to rise to the top.\n\n# For instance, take this example:\n# [1,1,2,3,2,4,2,5,2,6,2,7]\n# 2 is the only dominant element. But 1 has positive balance. So that won&#39;t work.\n\n# Additionally, we can&#39;t keep track of 2s because the balance keeps hitting 0.\n# That means that you _have to_ alternate because otherwise the other element never\n# gets rotated out.\n\n# Okay, what happens if you always target the one with more?\n# [1, 1, 2, 3, 4, 2, 2] 3 &gt; 2 = floor(7/3) -&gt; 2 dominant\n# Here, we eliminate 1, then 1 (or 2), and then if we eliminate 1, then 2 can come, but \n# 2 will always be in the final total.\n# But one might also be in the final total. \n\n# Wait, what if you always subtracted oldest added? That doesn&#39;t seem right.\n\n# Okay, I&#39;m confusing myself atp. Let&#39;s just try to implement something.\n```\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;subsets-ii&quot;],&quot;date&quot;:[0,&quot;2026-02-02&quot;],&quot;problem&quot;:[0,&quot;subsets-ii&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,10],&quot;topics&quot;:[1,[[0,&quot;backtracking&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;You are given an array nums of integers, which may contain duplicates. Return all possible subsets.\n\nThe solution must not contain duplicate subsets. You may return the solution in any order.\n\n## Approach\n\nThis is a simple backtracking problem. I opted for an iterative solution, kind of for no particular\nreason. It just seemed simpler. I build up my result by repeatedly appending to the subsets\ngenerated from the previous elements.\n\n## Solution\n\n```python\nclass Solution:\n    def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]:\n        count = collections.Counter(nums)\n\n        result = [[]]\n\n        for num in count:\n            new_result = result[:]\n            for partial in result:\n                for i in range(1, count[num]+1):\n                    new_result.append((partial + [num] * i))\n            \n            result = new_result\n\n        return result\n\n```\n\n## Complexity\n\n* Time: O(m^n), where m is the largest cardinality and n is the number of unique elements.\n* Space: O(m^n), since we have to store all the elements we generate anyway.\n\n## Results\n\nMemory 8MB, Time 28ms.\nBeats 97.44%, 100% respectively.\n\n## Next Steps\n\nI ran into an issue with array copying. I had to randomly slice arrays to prevent the shallow copy\nissue.\n\n## Notes\n\nN/A\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;find-k-closest-elements&quot;],&quot;date&quot;:[0,&quot;2026-02-01&quot;],&quot;problem&quot;:[0,&quot;find-k-closest-elements&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,5],&quot;topics&quot;:[1,[[0,&quot;array&quot;],[0,&quot;two-pointers&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Problem\n\nYou are given a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should also be sorted in ascending order.\n\nAn integer a is closer to x than an integer b if:\n\n|a - x| &lt; |b - x|, or\n|a - x| == |b - x| and a &lt; b\n\n[](https://neetcode.io/problems/find-k-closest-elements/question)\n\n## Approach\n\nIt&#39;s a two pointers problem. You can tell this because the array is sorted.\nAll you have to do is find the subarray that is closest to x. You start from the outside and work\nyour way in, stopping when your subarray is size k. At each step, you reject whichever element\nis further from x. You continue until your segment is size k. Because the element rejected is always\nthe one furthest away from x, and our subarray initially includes all elements, by rejecting n-k,\nyou guarantee that the remaining k are all the closest to x.\n\n## Solution\n\n```python\nclass Solution:\n    def findClosestElements(self, arr: List[int], k: int, x: int) -&gt; List[int]:\n        i = 0\n        j = len(arr)-1\n        \n        while (j - i + 1) &gt; k:\n            if x-arr[i] &gt; arr[j]-x:\n                i += 1\n            else:\n                j -= 1\n        return arr[i:j+1]\n\n```\n\n## Complexity\n\n* Time: O(n)\n* Space: O(1)\n\n## Results\n\n28ms, 8.7MB, beats 100%\n\n## Next Steps\n\nI think I could have explained this better\n\n## Notes\n\n\\[Any additional notes]\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;minimum-array-end&quot;],&quot;date&quot;:[0,&quot;2026-01-31&quot;],&quot;problem&quot;:[0,&quot;minimum-array-end&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,35],&quot;topics&quot;:[1,[[0,&quot;bit-manipulation&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Problem\n\nYou are given two integers n and x. You have to construct an array of positive integers nums of size n where for every 0 &lt;= i &lt; n - 1, nums\\[i + 1] is greater than nums\\[i], and the result of the bitwise AND operation between all elements of nums is x.\n\nReturn the minimum possible value of nums\\[n - 1].\n\n## Approach\n\nThis one was tricky. But all you have to do is realize that every number must include the bits of x,\notherwise the and operation will fail. Then you need to realize that we always want to pick the\nsmallest integer bigger than the current which has the bits of x. The smallest such element is x,\nso our first element is always x and any AND operation that includes extraneous bits (besides the\nones in x) will be removed from the final result. This means that we can set the remaining bits\nhowever we like, but it&#39;s best to do it in a way that always picks the smallest integer.\n\nHow do we do that? Well, the bits in x are constrained (forced to be 1). Furthermore, among the\nremaining bits, we should \&quot;count up in binary\&quot;. Doing so will give us the smallest final result\nbecause the ordering of integers corresponds to the lexicographic ordering of their binary strings.\n\nThis is the same trick that allows string timestamps to be compared.\n\nSo, how do we actually \&quot;count up in binary\&quot;? Well, all we need is the (n-1)th, element, which will\nhave the remaining bits (in lexicographic order) set according to the bits of n-1 among the bits\nnot set in x. Then it&#39;s a matter of implementation -- how do shift the bits in n-1 so that each\nplace value is shifted left the appropriate amount to a bit not set in x? I used a loop for this.\n\n## Solution\n\n```python\nclass Solution:\n    def minEnd(self, n: int, x: int) -&gt; int:\n\n        unset_bits = ~x\n        m = 0\n\n        n = n-1\n        i = 0\n        for i in range(32):\n            if n &gt;&gt; i == 0:\n                break\n            lowest_unset = unset_bits &amp; -unset_bits\n            if n &amp; (1 &lt;&lt; i):\n                m |= lowest_unset\n            unset_bits &amp;= ~lowest_unset\n\n        return x | m\n\n```\n\n## Complexity\n\n* Time: O(log n)\n* Space: O(1)\n\nI know that complexity is typically defined in terms of input length, but this number is usually\nwhat they mean.\n\n## Results\n\n99th percentile\n\n## Next Steps\n\n* Memorize the \&quot;first set bit\&quot; trick -- I had to look it up.\n\n## Notes\n\n```\nThe smallest number will be x (it has to be).\nBeyond that, we are setting bits which are not already set.\n\nFirst example:\nn = 011, x = 010, unset bits = 101, n - 1 = 010, \naligned:\nn - 1: 1 0\nunset: 101\n010\n011\n110\n\nSecond example:\nn = 101, x = 011\n00011\n00111\n01011\n01111\n10011\n```\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;design-twitter-feed&quot;],&quot;date&quot;:[0,&quot;2026-01-30&quot;],&quot;problem&quot;:[0,&quot;design-twitter-feed&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,25],&quot;topics&quot;:[1,[[0,&quot;hash-map&quot;],[0,&quot;heap&quot;],[0,&quot;merge&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nTwo options:\n\n1. Maintain a global list of tweets, and filter out tweets that are not followed by the current user\n2. Generate a feed by merging each user&#39;s tweets as needed, only ever processing the tweets of followees to determine the top 10.\n\nI gravitated towards the second approach because despite the efficiency of filtering a global list (which is very fast), the\ntotal number of tweets far exceeds the tweets for the set of followees. Furthermore, the worst case complexity would balloon\nfrom O(f + 10log f) = O(f) to O(n), where f is the number of followers for the user and n is the number of tweets total.\nIn most scenarios, f &lt;&lt; u &lt;&lt; n, where u is the number of users.\n\n## Solution\n\n```python\nimport itertools\n\nclass Twitter:\n\n    def __init__(self):\n        self.following = collections.defaultdict(set)\n        self.tweets = collections.defaultdict(list)\n        self.timeCounter = 0\n\n    def postTweet(self, userId: int, tweetId: int) -&gt; None:\n        self.timeCounter += 1\n        self.tweets[userId].append((self.timeCounter, tweetId))\n\n    def getNewsFeed(self, userId: int) -&gt; List[int]:\n        h = [self.tweets[followedUser][-1] + (followedUser, -1) \n            for followedUser in itertools.chain([userId], self.following[userId])\n            if len(self.tweets[followedUser]) &gt; 0]\n\n        heapq.heapify_max(h)\n\n        result = []\n\n        for _ in range(10):\n            if len(h) == 0:\n                return result\n            _, tweetId, user, idx = heapq.heappop_max(h)\n            print(_, tweetId, user, idx)\n            result.append(tweetId)\n            if len(self.tweets[user]) &lt; -(idx-1):\n                continue\n            heapq.heappush_max(h, self.tweets[user][idx-1] + (user, idx-1))\n\n        return result\n\n    def follow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId == followeeId:\n            return\n        self.following[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId == followeeId:\n            return\n        self.following[followerId].discard(followeeId)\n\n\n```\n\n## Complexity\n\nTime:\n\n* postTweet: O(1)\n* follow: O(1)\n* unfollow: O(1)\n* getNewsFeed: O(u), where u is the number of users\n  Space:\n* O(n + u), where n, and u are the number of tweets and followers\n\n## Results\n\n* Memory: 7.9MB\n* Time: 29ms\n\n## Next Steps\n\nI made some mistakes because this was a real world data structure with some invalid operations. I should have handled them\nbetter as if it was a real API, especially considering the flavour of the question.\n\n## Notes\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;merge-triplets-to-form-target&quot;],&quot;date&quot;:[0,&quot;2026-01-27&quot;],&quot;problem&quot;:[0,&quot;merge-triplets-to-form-target&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,10],&quot;topics&quot;:[1,[[0,&quot;array&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nThe key was to realize that max is special because it is equal to its larger argument. Therefore,\nthere would have to be at least one combining element where target is equal to the element in each\nof the three values (repeats possible). Furthermore, as soon as you combine an element that is\nlarger in at least one of the positions, that entire triplet is now worthless, as you can never\nget it back down to the target. Therefore, we need elements that contain one of the numbers in\ntarget, but otherwise are, at worst, smaller or equal to target in the other positions. Then it was\nclear that you could pick 3 such elements to create such a target, regardless of the rest of the\narray. Therefore I found that finding these three elements was a both sufficient and necessary\ncondition. So that&#39;s exactly what I did, in linear time. Though the implementation could use work.\nIt&#39;s just a matter of iterating and filtering.\n\n## Solution\n\n::include{file=\&quot;solution.py\&quot;}\n\n## Complexity\n\n* Time: O(n)\n* Space: O(1)\n\n## Results\n\n27ms, 7.7MB\n\n## Next Steps\n\nCould have solved it faster / more elegantly. I should do a second pass where I clean up my code\nmore often.\n\n## Notes\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;missing-number&quot;],&quot;date&quot;:[0,&quot;2026-01-26&quot;],&quot;problem&quot;:[0,&quot;missing-number&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;easy&quot;],&quot;time_minutes&quot;:[0,0],&quot;topics&quot;:[1,[[0,&quot;array&quot;],[0,&quot;sorting&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nBecause the integers span from \\[0, .., n] except for one, and the indexes are from \\[0, ..., n-1],\nit actually makes it easy to \&quot;bucket sort\&quot; everything to its corresponding index. The first\nloop takes some technique -- you have to know that you need to repeatedly place all smaller elements\nthan the current, because swapping may surface an element that is smaller that is misplaced.\n\nAfter that, it&#39;s just a linear scan.\n\n## Solution\n\n```python\nclass Solution:\n    def missingNumber(self, nums: List[int]) -&gt; int:\n        for i in range(len(nums)):\n            while nums[i] &lt; i:\n                nums[nums[i]], nums[i] = nums[i], nums[nums[i]]\n        for i in range(len(nums)):\n            if nums[i] != i:\n                return i\n        else:\n            return len(nums)\n\n```\n\n## Complexity\n\n* Time: O(n)\n* Space: O(n) (O(1) additional)\n\n## Results\n\nBeats 100% (27 ms). Neetcode has started tracking percentiles.\n\n## Next Steps\n\nI did have some false submissions. Need to get better at producing bug-free code the first time.\n\n## Notes\n\nN/A\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;delete-leaves-with-a-given-value&quot;],&quot;date&quot;:[0,&quot;2026-01-24&quot;],&quot;problem&quot;:[0,&quot;delete-leaves-with-a-given-value&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,0],&quot;topics&quot;:[1,[[0,&quot;binary-tree&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nThere should be a tier of problems that&#39;s between easy and medium just for binary tree recursion problems. But I&#39;ll take the free medium.\n\nAll you have to do with this one is do a postorder traversal (visit children before their parents). If you make the function return the new\ntree, then you can determine whether the current node is a leaf after removing the target from its children. If it is, and the target\nmatches the node value, then you `return None`, otherwise, return the node as-is.\n\n## Solution\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def removeLeafNodes(self, root: Optional[TreeNode], target: int) -&gt; Optional[TreeNode]:\n        if root is None:\n            return None\n        root.left = self.removeLeafNodes(root.left, target)\n        root.right = self.removeLeafNodes(root.right, target)\n        if root.left or root.right:\n            return root\n        if root.val == target:\n            return None\n        return root\n\n```\n\n## Complexity\n\n* Time: O(n)\n* Space: O(n) (O(1) additional)\n\n## Results\n\n0.037s\n\n## Next Steps\n\nNeed to practice iterative traversals. Easiest way to go from recursive to iterative is to simulate the stack.\n\n## Notes\n\n\\[Any additional notes]\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;trapping-rain-water&quot;],&quot;date&quot;:[0,&quot;2026-01-24&quot;],&quot;problem&quot;:[0,&quot;trapping-rain-water&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;hard&quot;],&quot;time_minutes&quot;:[0,90],&quot;topics&quot;:[1,[[0,&quot;stack&quot;],[0,&quot;two-pointers&quot;],[0,&quot;dp&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nThis one was harder than I expected. I expected it to fall quickly to the monotone stack, but it put up surprising resistance.\nI just bashed my head against edge cases until I was able to do it successfully.\n\nThe idea is this: you store the highest boundaries seen so far in a decreasing monotone stack, and once you encounter a right\nboundary that is higher than some boundary on the stack, you fill up to the lower of the two boundaries, and increase the water\nlevel up to the height of that lower boundary. For instance, let&#39;s say you have this:\n\n```\n#   #\n#   #\n#@# #\n    ^\n```\n\nLet&#39;s say you encounter the right boundary. `@` represents water, `#` represents wall. When we first encounter the right boundary,\nour stack looks like \\[0, 2] (pointing to the first and second walls). On the first stage, we pop out the first lower wall (2), and\nit looks like this:\n\n```\n#   #\n#   #\n#@#@#\n```\n\nWe set `water_line = 1`. Then, when we do the next step, we don&#39;t recount the bottom layer of water and wall (3 cells). The second step\n(which is also after we exit the loop, looks like this:\n\n```\n#@@@#\n#@@@#\n#@#@#\n```\n\nAnd then we are done.\n\n## Solution\n\nThere are much better solutions, and my code is inelegant. However, I&#39;m first committing the minimum.\n\n```python\nclass Solution:\n    def trap(self, height: List[int]) -&gt; int:\n        stack = []\n        total = 0\n        for i, col in enumerate(height):\n            water_line = 0\n            while len(stack) &gt; 0 and height[stack[-1]] &lt; col:\n                j = stack[-1]\n                total += (\n                    (i - j - 1) # width of in-between cells\n                    * (min(height[j], height[i]) - water_line)\n                )\n                water_line = height[j]\n                stack.pop()\n            if len(stack) &gt; 0:\n                j = stack[-1]\n                total += (\n                    (i - j - 1) # width of in-between cells\n                    * (min(height[j], height[i]) - water_line)\n                )\n                # print(total)\n            stack.append(i)\n        return total\n\n```\n\n## Complexity\n\n* Time: O(n)\n* Space: O(n) (O(n) additional)\n\n## Results\n\n0.028s\n\n## Next Steps\n\nI want to try the DP approach, where you simply compute the highest boundary to the left and to the right.\nI also want to try the two pointer approach, which is basically the same as DP but O(1) space by computing\nthe recurrence \&quot;just in time\&quot;. A recurrence might not seem possible, until you realize that the water level\nwill alway increase monotonically before decreasing monotonically.\n\n## Notes\n\n\\[Any additional notes]\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;count-connected-components&quot;],&quot;date&quot;:[0,&quot;2026-01-23&quot;],&quot;problem&quot;:[0,&quot;count-connected-components&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,10],&quot;topics&quot;:[1,[[0,&quot;graph&quot;],[0,&quot;dfs&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nIf you&#39;ve ever done \&quot;count islands\&quot;, it&#39;s pretty similar to that. It&#39;s just that the adjacency is determined by a graph\ninstead of by an actual grid. All you have to do is maintain a global visited array, so that every node is visited at most\nonce. Nodes in the same component are grouped together because they will be visited in the same dfs, whereas nodes in other\ncomponents belong to separated to top level dfs calls. All this means that if we count each dfs at most once, skipping over\nsituations where a call is made on an already visited node (because it&#39;s part of a component that we&#39;ve already touched),\nwe&#39;ll get the number of components\n\n## Solution\n\n```python\nclass Solution:\n    def countComponents(self, n: int, edges: List[List[int]]) -&gt; int:\n        g = [[] for _ in range(n)]\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n\n        vis = [False] * n\n\n        def dfs(start):\n            if vis[start]:\n                return False\n            vis[start] = True\n            for adj in g[start]:\n                dfs(adj)\n            return True\n\n        total_components = 0\n        for s in range(n):\n            total_components += int(dfs(s))\n\n        return total_components\n\n```\n\n## Complexity\n\n* Time: O(n) -- proportional to edges\n* Space: O(n) -- we create an O(n) auxiliary data structure.\n\n## Results\n\n0.028s -- I have a feeling neetcode will start tracking percentiles soon.\n\n## Next Steps\n\n\\[Future improvements or learnings]\n\n## Notes\n\n\\[Any additional notes]\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;binary-tree-from-preorder-and-inorder-traversal&quot;],&quot;date&quot;:[0,&quot;2026-01-19&quot;],&quot;problem&quot;:[0,&quot;binary-tree-from-preorder-and-inorder-traversal&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,0],&quot;topics&quot;:[1,[[0,&quot;binary-tree&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nThis was a tricky one, with multiple failed submissions (although, I do think that I should partly blame the broken tester. I will have to start creating my own\nharness eventually).\n\nThe idea is this: use the inorder traversal + a hashmap to decide whether any two nodes should appear before or after each other in the binary tree. Then, use the preorder\ntraversal to construct the root, then the left subtree, then the right subtree, yielding if the current node ever appears to the right of the parent.\n\nIn other words, consume as many nodes as possible, and then return with the constructed tree, and a pointer to the remainder of the preorder nodes.\n\n## Solution\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    \n    def buildTreeRec(self, preorder: List[int], order: Dict[int, int], cutoff: int):\n        root = TreeNode(preorder[self.i])\n\n        self.i += 1\n        if self.i &gt;= len(preorder):\n            return root\n\n        if order[preorder[self.i]] &lt; order[root.val]:\n            root.left = self.buildTreeRec(preorder, order, order[root.val])\n        if self.i &gt;= len(preorder):\n            return root\n        if order[preorder[self.i]] &lt; cutoff:\n            root.right = self.buildTreeRec(preorder, order, cutoff)\n    \n        return root\n    \n    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n        order = {v: i for i, v in enumerate(inorder)}\n        self.i = 0\n\n        return self.buildTreeRec(preorder, order, len(inorder))\n\n```\n\n## Complexity\n\n* Time: O(n)\n* Space: O(n)\n\n## Results\n\n\\[Add performance metrics here, or N/A if not applicable]\n\n## Next Steps\n\nI do need to learn how the tester works. Also, I need to start maintaining my own solution set, and my own testing harness, because I can&#39;t afford errors on real coding challenges.\n\n## Notes\n\n\\[Any additional notes]\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;longest-consecutive-sequence&quot;],&quot;date&quot;:[0,&quot;2026-01-19&quot;],&quot;problem&quot;:[0,&quot;longest-consecutive-sequence&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,30],&quot;topics&quot;:[1,[[0,&quot;arrays&quot;],[0,&quot;hash-map&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nThis one honestly stumped me. I was worried about the order in which I see elements, and it didn&#39;t occur to me that I could just use the fact\nthat the next element in the sequence was always going to be 1+the current element, which meant I could do an O(1) set lookup to extend a sequence.\n\nOnce that was clear to me, I just had to find a way to find the starting element of every sequence.\n\n## Solution\n\n```python\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -&gt; int:\n        # okay, I think we&#39;ll probably have to use hashing for this.\n        # We could try a strategy where I make a sequence that runs\n        # like \n\n        starts = set()\n        s = set(nums)\n\n        for n in s:\n            while n-1 in s:\n                n -= 1\n            starts.add(n)\n\n\n        maxi = 0\n        for i in starts:\n            j = 0\n            while i+j in s:\n                j += 1\n            maxi = max(maxi, j)\n        return maxi\n\n```\n\n## Complexity\n\n* Time: O(?)\n* Space: O(?)\n\n## Results\n\n\\[Add performance metrics here, or N/A if not applicable]\n\n## Next Steps\n\n\\[Future improvements or learnings]\n\n## Notes\n\n```\n# okay, I think we&#39;ll probably have to use hashing for this.\n# We could try a strategy where I make a sequence that runs\n# like \n```\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;daily-temperatures&quot;],&quot;date&quot;:[0,&quot;2026-01-18&quot;],&quot;problem&quot;:[0,&quot;daily-temperatures&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,5],&quot;topics&quot;:[1,[[0,&quot;monotone-stack&quot;],[0,&quot;stack&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nMonotone stack problem I&#39;ve seen before. I can&#39;t possibly come up with a better explanation\nthan the video I watched to understand it the first time:\n\n[](https://www.youtube.com/watch?v=J7Ll0I-GSwA)\n\n## Solution\n\n```python\nclass Solution:\n    def dailyTemperatures(self, temperatures: List[int]) -&gt; List[int]:\n        # monotone stack, can go in reverse:\n        result = [0] * len(temperatures)\n        s = []\n        for i, temp in reversed(list(enumerate(temperatures))):\n            while len(s) &gt; 0 and temp &gt;= s[-1][1]:\n                s.pop()\n            if len(s) &gt; 0:\n                result[i] = (s[-1][0] - i)\n            s.append((i, temp))\n        return result\n\n```\n\n## Complexity\n\n* Time: O(n)\n* Space: O(n) (O(n) additional)\n\n## Results\n\n\\[Add performance metrics here, or N/A if not applicable]\n\n## Next Steps\n\nI made a mistake with less than or equal. I also didn&#39;t know how to reverse an iterator, or\nthat enumerate can&#39;t be directly reversed. All this slowed me down and made me noob-ish\n\n## Notes\n\n```\n# monotone stack, can go in reverse\n```\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;coin-change&quot;],&quot;date&quot;:[0,&quot;2026-01-17&quot;],&quot;problem&quot;:[0,&quot;coin-change&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,0],&quot;topics&quot;:[1,[[0,&quot;bfs&quot;],[0,&quot;dynamic-programming&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nI went with a BFS solution to this problem. If we view each total as a node in a graph, a BFS\nwill give us the shortest path (fewest number of coins) to the solution.\n\nDynamic programming is another approach. There, you can do it just by incrementing arrays,\nassuming no coins are negative.\n\n## Solution\n\n```python\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -&gt; int:\n        queue = [0]\n\n        coins.sort()\n\n        vis = set()\n        num_coins = 0\n        while len(queue) &gt; 0 and queue[0] &lt;= amount:\n            new_q = []\n            for total in queue:\n                if total == amount:\n                    return num_coins\n                elif total in vis:\n                    continue\n                vis.add(total)\n                new_q.extend(coin+total for coin in coins)\n            queue = new_q\n            num_coins += 1\n        return -1\n\n\n```\n\n```python\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -&gt; int:\n        coins.sort()\n        dp = [0] + [float(&#39;inf&#39;)] * amount\n        for i in range(amount+1):\n            for c in coins:\n                if i+c &gt; amount:\n                    break\n                dp[i+c] = min(dp[i]+1, dp[i+c])\n        return dp[amount] if dp[amount] &lt;= 10000 else -1\n\n```\n\n## Complexity\n\n* Time: O(nt) - because we iterate through every edge at every node, and every outdegree is t,\n  the number of coins.\n* Space: O(n) -- because there are at most n nodes, and we hit all of them\n\n## Results\n\nN/A\n\n## Next Steps\n\nTODO\n\n## Notes\n\n\\[Any additional notes]\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;last-stone-weight&quot;],&quot;date&quot;:[0,&quot;2026-01-17&quot;],&quot;problem&quot;:[0,&quot;last-stone-weight&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;easy&quot;],&quot;time_minutes&quot;:[0,0],&quot;topics&quot;:[1,[[0,&quot;heap&quot;],[0,&quot;implementation&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Problem:\n\n&gt; You are given an array of integers stones where stones\\[i] represents the weight of the ith stone.\n&gt;\n&gt; We want to run a simulation on the stones as follows:\n&gt;\n&gt; At each step we choose the two heaviest stones, with weight x and y and smash them togethers\n&gt; If x == y, both stones are destroyed\n&gt; If x &lt; y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\n&gt; Continue the simulation until there is no more than one stone remaining.\n&gt;\n&gt; Return the weight of the last remaining stone or return 0 if none remain.\n\n## Approach\n\nThe bounds of the problem mean that you can search the entire array\nn times, resulting in an `n^2` algorithm without running into any\nproblems. The only small optimization was to use a max-heap, which\nturned the finding operation from O(n) to O(log n).\n\n## Solution\n\n```python\nclass Solution:\n    def lastStoneWeight(self, stones: List[int]) -&gt; int:\n        heapq.heapify_max(stones)\n        while True:\n            l = heapq.heappop_max(stones)\n            if len(stones) &gt; 0:\n                r = heapq.heappop_max(stones)\n                if r == 0:\n                    return l\n                heapq.heappush_max(stones, l-r)\n            else:\n                return l\n\n\n```\n\n## Complexity\n\n* Time: O(n log n)\n* Space: O(n) (O(1) additional)\n\n## Results\n\nN/A\n\n## Next Steps\n\nCould handle edge cases better. Still not testing or dictating.\n\n## Notes\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;longest-common-subsequence&quot;],&quot;date&quot;:[0,&quot;2026-01-16&quot;],&quot;problem&quot;:[0,&quot;longest-common-subsequence&quot;],&quot;source&quot;:[0,&quot;leetcode&quot;],&quot;difficulty&quot;:[0,&quot;easy&quot;],&quot;time_minutes&quot;:[0,0],&quot;topics&quot;:[1,[]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nPretty standard DP -- I&#39;ve seen this one before. The idea is that we store an 2d array which stores\nthe longest common subsequence between `text1[:i], text2[:j]` at index `i, j`. This allows\n\n## Solution\n\n```python\nclass Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -&gt; int:\n        n = len(text2)\n        m = len(text1)\n        \n        dp = [[0] * (n+1) for _ in range(m+1)]\n        \n        for i in range(1,m+1):\n            for j in range(1,n+1):\n                dp[i][j] = max(dp[i-1][j-1] + int(text1[i-1] == text2[j-1]), dp[i-1][j], dp[i][j-1])\n        return dp[m][n]\n\n\n```\n\n## Complexity\n\n* Time: O(mn)\n* Space: O(mn)\n\n## Results\n\nN/A\n\n## Next Steps\n\nMake fewer mistakes; stop running code directly in neetcode and make own harness\n\n## Notes\n\n```\n# So dp[i][j] will represent the longest common subsequence between\n# text1[:i], text2[:j]\n```\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;reverse-bits&quot;],&quot;date&quot;:[0,&quot;2026-01-16&quot;],&quot;problem&quot;:[0,&quot;reverse-bits&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;easy&quot;],&quot;time_minutes&quot;:[0,5],&quot;topics&quot;:[1,[[0,&quot;bit-manipulation&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nDo you know your shift operators? If you don&#39;t, you should. Remember that `&lt;&lt;` and `&gt;&gt;` have higher precedence than you&#39;d expect -- you&#39;ll have to parenthesize if the shift is computed. But once you know\nthat, you&#39;re basically just reversing a little array, with different ops. Quite unique.\n\n## Solution\n\n```python\nclass Solution:\n    def reverseBits(self, n: int) -&gt; int:\n        print(\&quot;{0:b}\&quot;.format(n))\n        r = 0\n        for i in range(32):\n            r |= ((n &gt;&gt; i) &amp; 0b1) &lt;&lt; (31-i)\n        print(\&quot;{0:b}\&quot;.format(r))\n        return r\n\n\n```\n\n## Complexity\n\n* Time: O(n)\n* Space: O(n)\n\nI&#39;m going to go with O(n) because the `length` of the number is proportional to its bit count. And\ntime complexity is specified in terms of the length of the input. If we had to reverse a 128 bit\nnumber, it&#39;d take 128 operations.\n\n## Results\n\nN/A\n\n## Next Steps\n\nI didn&#39;t do the optimal solution. But mine is pretty good.\n\n## Notes\n\n\\[Any additional notes]\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;design-word-search-data-structure&quot;],&quot;date&quot;:[0,&quot;2026-01-15&quot;],&quot;problem&quot;:[0,&quot;design-word-search-data-structure&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,20],&quot;topics&quot;:[1,[[0,&quot;trie&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nIt&#39;s like a trie. The only wrinkle is &#39;.&#39; means that you need to follow all paths at the position\nyou&#39;re currently at. If you generalize the trie to a set of tries, not worrying about duplication\nbecause it&#39;s a tree, you can just iterate through every letter and maintain a solution set,\nrejecting when there&#39;s no branch to take.\n\n## Solution\n\n```python\nclass WordDictionary:\n\n    def __init__(self):\n        def trie():\n            return collections.defaultdict(trie)\n        self.trie = trie()\n\n    def addWord(self, word: str) -&gt; None:\n        cur = self.trie\n        for c in word:\n            cur = cur[c]\n        cur[\&quot;$\&quot;] = True\n\n\n    def search(self, word: str) -&gt; bool:\n        subtrees = [self.trie]\n        for c in word:\n            if len(subtrees) == 0:\n                return False\n            new_subtrees = []\n            if c == &#39;.&#39;:\n                for subtree in subtrees:\n                    new_subtrees.extend(subtree[c] for c in subtree if c != \&quot;$\&quot;)\n            else:\n                for subtree in subtrees:\n                    if c in subtree:\n                        new_subtrees.append(subtree[c])\n            subtrees = new_subtrees\n        return any([\&quot;$\&quot; in subtree for subtree in subtrees])\n        \n\n\n```\n\n## Complexity\n\n* Time: O(m)\n* Space: O(m)\n\n## Results\n\nN/A\n\n## Next Steps\n\nCould stand to test my code better. I missed an edge case where we don&#39;t extend to &#39;$&#39;.\n\n## Notes\n\nN/A\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;reverse-linked-list-ii&quot;],&quot;date&quot;:[0,&quot;2026-01-15&quot;],&quot;problem&quot;:[0,&quot;reverse-linked-list-ii&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,30],&quot;topics&quot;:[1,[[0,&quot;linked-list&quot;],[0,&quot;implementation&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nIt&#39;s not particularly complicated, just tricky. There are three main steps to this problem:\n\n* Going to the node before the `left`th nodj in the linked list -- can be done easily using a dummy pointer approach; so that `cur.next` is the `left`th node\n* Reversing the linked list\n* Stitching the three pieces back together\n\nThis just requires delicate pointer surgery, which took me multiple failed attempts.\n\nBut I asked ChatGPT, and it gave me another, more elegant solution. Take for example this test case:\n\n```\n[1, 2, 3, 4, 5, 6, 7]\nleft = 3\nright = 5\n```\n\nExpected result:\n\n```\n[1, 2, 5, 4, 3, 6, 7]\n```\n\nAre you familiar with head insertion? Because that&#39;s the trick we&#39;re going to use.\n\n* You can reverse a linked list by popping from the head and inserting at the head\n  * It&#39;s like two stacks.\n* If we keep popping the next node from the from the first node, `left`, and then inserting it\n  immediately after `left - 1`, because of the way that we encounter nodes the entire list will\n  become `..., left - 1, right, right - 1, ..., left + 1, left, right + 1, right + 2, ...`\n* The grand insight here is that it&#39;s all just splicing. That&#39;s why linked list ops often come\n  in 4 assignments. 2 to remove (save removed node, and assing prev.next = node.next), and\n  2 to splice (set node.next and new prev.next = node).\n\n## Solution\n\nTwo solutions this time. Number 1 (old):\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -&gt; Optional[ListNode]:\n        dummy = ListNode(next=head)\n        \n        cur = dummy\n\n        for _ in range(1, left):\n            cur = cur.next\n\n        l = cur.next\n\n        p = cur\n        r = cur.next\n        for _ in range(right - left + 1):\n            tmp = r.next\n            r.next = p\n            p = r\n            r = tmp\n        else:\n            l.next = r\n            cur.next = p\n        return dummy.next\n        \n\n```\n\nNumber 2 (ChatGPT):\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -&gt; Optional[ListNode]:\n        if not head or left == right:\n            return head\n        \n        dummy = ListNode(0, head)\n        pre = dummy\n\n        for _ in range(left - 1):\n            pre = pre.next\n        \n        cur = pre.next\n        for _ in range(right - left):\n            nxt = cur.next\n            cur.next = nxt.next\n            nxt.next = pre.next\n            pre.next = nxt\n\n        return dummy.next\n\n\n```\n\n## Complexity\n\n* Time: O(n)\n* Space: O(n)\n\n## Results\n\n## Next Steps\n\nRemember this for next implementation\n\n## Notes\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;count-good-nodes-in-binary-tree&quot;],&quot;date&quot;:[0,&quot;2026-01-14&quot;],&quot;problem&quot;:[0,&quot;count-good-nodes-in-binary-tree&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,5],&quot;topics&quot;:[1,[[0,&quot;binary-tree&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nBinary trees problems are easy because they lend themselves to straightforward recursion.\n\nHere, as we go down a tree, we have to determine whether we have seen any nodes larger than the\ncurrent node. This is not hard, if we store a max per path.\n\nCombine that with the fact that the total number of good nodes is the sum of the nodes in the two\nsubtrees, and all we have to do is recursively call the main function across the two subtrees.\n\n## Solution\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def goodNodes(self, root: TreeNode, max_seen:int=float(&#39;-inf&#39;)) -&gt; int:\n        if not root:\n            return 0\n\n        total = 0\n        if root.val &gt;= max_seen:\n            max_seen = root.val\n            total += 1\n\n        total += self.goodNodes(root.left, max_seen)\n        total += self.goodNodes(root.right, max_seen)\n        \n        return total\n\n```\n\n## Complexity\n\n* Time: O(n)\n* Space: O(n)\n\n## Results\n\nN/A\n\n## Next Steps\n\nGot this one first try. Maybe explain it better.\n\n## Notes\n\nNo notes.\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;house-robber&quot;],&quot;date&quot;:[0,&quot;2026-01-14&quot;],&quot;problem&quot;:[0,&quot;house-robber&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,10],&quot;topics&quot;:[1,[[0,&quot;dynamic-programming&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nI&#39;ve seen this one before -- it&#39;s a classic DP problem.\n\nEvery DP problem consists of two things:\n\n1. overlapping subproblems - a problem which can be decomposed into subproblems, where each\n   subproblem is used more than once in evaluating the solution to the whole. A trivial example\n   is computing x^n: it can be decomposed in terms of x^(n%2) \\* x^(n/2) \\* x^(n/2), where x^(n/2)\n   can be computed once instead of twice / reused. This is the foundation of the exponentiation\n   by squaring algorithm which computes exponents in O(log n) time.\n2. optimal substructure - a problem where an optimal solution can be constructed efficiently from\n   an optimal solution to the subproblems. In this example, the optimal solution to determining\n   which houses to rob on the street can be decomposed as the problem of determining whether\n   to rob the current house or the house before it, provided all the houses to the left are\n   robbed optimally. To be more precise, assuming we know how best to rob the subarray \\[0, ..., i-1],\n   and \\[0, ..., i], whether to rob the (i+1)st house depends on whether the sum from \\[0, ..., i] is\n   larger than the sub from \\[0, ..., i-1] + nums\\[i]. Notice that we access the solution to the\n   subproblem \\[0, ..., i] twice, once when calculating whether to rob i+1 and once when calculating\n   i+2. If we didn&#39;t cache this with our dp array, we&#39;d run into an exponential blowup, as each\n   problem depends on two smaller subproblems. But because they overlap, we can compute the solution\n   once instead of `2^recursion_depth`. And because of optimality, we are always going to rely\n   on the best known solution, instead of having to select a solution that isn&#39;t as good now\n   in order to get a better one later.\n\n## Solution\n\n```python\nclass Solution:\n    def rob(self, nums: List[int]) -&gt; int:\n        if len(nums) &lt; 2:\n            return sum(nums)\n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[1], nums[0])\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n        return dp[len(dp)-1]\n\n```\n\n## Complexity\n\n* Time: O(n)\n* Space: O(n)\n\n## Results\n\nN/A\n\n## Next Steps\n\n* Could do well to create fewer bugs / false submissions\n\n## Notes\n\nN/A\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;roman-to-integer&quot;],&quot;date&quot;:[0,&quot;2026-01-14&quot;],&quot;problem&quot;:[0,&quot;roman-to-integer&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;easy&quot;],&quot;time_minutes&quot;:[0,5],&quot;topics&quot;:[1,[[0,&quot;implementation&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nThis isn&#39;t hard, it just requires some creativity to handle the edge cases. The fact that the\nroman numeral is guaranteed to be valid makes it easier too. Every character in a roman numeral\nadds to the value, unless it appears to the left of something larger, in which case, it subtracts\nfrom the one to the right of it -- this can be implemented by subtracting from a total, and iterating\nin reverse so we never have to look ahead.\n\n## Solution\n\n```python\nclass Solution:\n    def romanToInt(self, s: str) -&gt; int:\n        m = dict(\n            I=1,\n            V=5,\n            X=10,\n            L=50,\n            C=100,\n            D=500,\n            M=1000\n        )\n        \n        largest_seen=&#39;I&#39;\n        total = 0\n        for c in s[::-1]:\n            if m[c] &lt; m[largest_seen]:\n                total -= m[c]\n            else:\n                largest_seen = c\n                total += m[c]\n        return total\n\n```\n\n## Complexity\n\n* Time: O(n)\n* Space: O(n)\n\n## Results\n\nN/A\n\n## Next Steps\n\nNo syntax errors ideally\n\n## Notes\n\n\\[Any additional notes]\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;binary-tree-right-side-view&quot;],&quot;date&quot;:[0,&quot;2026-01-11&quot;],&quot;problem&quot;:[0,&quot;binary-tree-right-side-view&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,5],&quot;topics&quot;:[1,[[0,&quot;binary-tree&quot;],[0,&quot;recursion&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nIf we do a preorder traversal, but start with the right subtree, then the rightmost node at every\nlevel will be the node that we first encounter. Also, because we always encounter a parent before its child, it&#39;s enough to monotonically extend the list if we encounter a new node at a depth greater\nthan the max depth of the current list (which is equal to its length - 1).\n\nThen it&#39;s just a matter of doing a preorder traversal with the right subtree first.\n\n## Solution\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -&gt; List[int]:\n        \n        rightView = []\n\n        def rightSideViewRec(cur: Optional[TreeNode], depth=0):\n            nonlocal rightView\n\n            if not cur:\n                return\n\n            if depth &gt;= len(rightView):\n                rightView.append(cur.val)\n\n            rightSideViewRec(cur.right, depth=depth+1)\n            rightSideViewRec(cur.left, depth=depth+1)\n        \n        rightSideViewRec(root)\n\n        return rightView\n            \n\n\n\n\n\n```\n\n## Complexity\n\n* Time: O(n)\n* Space: O(n) (O(n) additional worst case, O(log n) on average)\n\n## Results\n\nN/A\n\n## Next Steps\n\nNone. This one was pretty easy. For the explanation, I clicked into the solution because I was\na little confused about the test case generation. I need to stop doing that.\n\n## Notes\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;k-closest-points-to-origin&quot;],&quot;date&quot;:[0,&quot;2026-01-10&quot;],&quot;problem&quot;:[0,&quot;k-closest-points-to-origin&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,20],&quot;topics&quot;:[1,[[0,&quot;heap&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nYou can keep a running tally of the top `k` elements according to some measure in O(nlog k)\ntime, as long as you have a data structure that can insert an element / eject the smallest element\nin O(log m) time, where m is the size of the data structure. Setting m = k, the idea is to iterate\nthrough the list of elements and repeatedly insert an element, ejecting when we exceed m, our count.\nThis results in a complexity of O(n) \\* (O(log k) + O(log k)) = O(n log k), which is the best\nthat we can do.\n\nA max-heap is the data structure that satisfies this O(log k) requirement. Because older versions\nof Python use a min-heap (which ejects the smallest element), you can negate the keys to order in\nthe opposite way). This is sufficient.\n\n## Solution\n\n```python\nclass Solution:\n    def kClosest(self, points: List[List[int]], k: int) -&gt; List[List[int]]:\n\n        def distance(p):\n            return p[0]*p[0]+p[1]*p[1]\n\n        h = []\n\n        for p in points:\n            d = distance(p)\n            if len(h) &lt; k:\n                heapq.heappush(h, (-d, p))\n            else:\n                heapq.heappushpop(h, (-d, p))\n            # print((d,p))\n\n        return [p for (d, p) in h]\n\n```\n\n## Complexity\n\n* Time: O(n log k)\n* Space: O(n) (O(k) additional)\n\n## Results\n\n0.71 seconds\n\n## Next Steps\n\nI got max and min heap confused, and had to look up documentation which slowed me down. Just need\nmore practice.\n\n## Notes\n\nN/A\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;two-sum&quot;],&quot;date&quot;:[0,&quot;2026-01-10&quot;],&quot;problem&quot;:[0,&quot;two-sum&quot;],&quot;source&quot;:[0,&quot;leetcode&quot;],&quot;difficulty&quot;:[0,&quot;easy&quot;],&quot;time_minutes&quot;:[0,5],&quot;topics&quot;:[1,[[0,&quot;array&quot;],[0,&quot;hash-map&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Problem\n\nGiven an array of integers `nums` and an integer `target`, return the indices `i` and `j` such that `nums[i] + nums[j] == target` and `i != j`.\n\nYou may assume that every input has exactly one pair of indices `i` and `j` that satisfy the condition.\n\nReturn the answer with the smaller index first.\n\n## Approach\n\nNotice that we if we have to construct a sum of k numbers to equal target t, we can fix\nk-1 elements and search for $$t-(n\\_0+...+n\\_{k-1})$$. This can be further improved upon\nby storing the seen numbers in a structure that allows us to easily verify membership,\nalong with a map from the number to any of its indexes in the array, because that&#39;s what\nwe want to return. A hash map is best for this, or as it&#39;s known in python, a dict. So\nwe iterate through the array, adding each number we&#39;ve seen to the dict while simultaneously\nchecking if the number `target - number` is already in the dict. And if it is, we return\nthe indices corresponding to these two numbers. It&#39;s also made easier by the fact\nthat a solution is guaranteed to both exist and be unique, but even if it weren&#39;t we could\nreturn \\[-1, -1] indicating no solution.\n\n## Solution\n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n        seenAt = {}\n        for i, num in enumerate(nums):\n            if target - num in seenAt:\n                return [seenAt[target-num], i]\n            seenAt[num] = i\n        return [-1, -1]\n\n```\n\n## Complexity\n\n* Time: O(n)\n* Space: O(n)\n\n## Results\n\nN/A\n\n## Next Steps\n\nN/A\n\n## Notes\n\nclassic. hashmap, store each seen num, check if target - cur is in nums\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;valid-parenthesis-string&quot;],&quot;date&quot;:[0,&quot;2026-01-08&quot;],&quot;problem&quot;:[0,&quot;valid-parenthesis-string&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,30],&quot;topics&quot;:[1,[[0,&quot;stack&quot;],[0,&quot;string&quot;],[0,&quot;implementation&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nTODO\n\n## Solution\n\n```python\nclass Solution:\n    def checkValidString(self, s: str) -&gt; bool:\n        d = 0\n        t = 0\n\n        for c in s:\n            if c == &#39;(&#39;:\n                d += 1\n            if c == &#39;*&#39;:\n                t += 1\n            if c == &#39;)&#39;:\n                if d &gt; 0:\n                    d -= 1\n                elif t &gt; 0:\n                    t -= 1\n                else:\n                    return False\n        if d - t &gt; 0:\n            return False\n\n        d = 0\n        t = 0\n        for c in s[::-1]:\n            if c == &#39;)&#39;:\n                d += 1\n            if c == &#39;*&#39;:\n                t += 1\n            if c == &#39;(&#39;:\n                if d &gt; 0:\n                    d -= 1\n                elif t &gt; 0:\n                    t -= 1\n                else:\n                    return False\n        if d - t &gt; 0:\n            return False\n\n\n        return True\n\n```\n\n## Complexity\n\n* Time: O(?)\n* Space: O(?)\n\n## Results\n\nN/A\n\n## Next Steps\n\nTry the \&quot;superposition\&quot; solution -- reproduce from memory (max\\_depth &amp; min\\_depth within a range)\n\n## Notes\n\n```\n&#39;()(())&#39;\n ( -&gt; 1\n ) -&gt; 0\n ( -&gt; 1\n ( -&gt; 2\n ) -&gt; 1\n ) -&gt; 0\n\n &#39;)(&#39;\n ) -&gt; -1 (not allowed, return false)\n\n((**)\n((())\n\n can never go below 0\n ( -&gt; increase depth by 1\n ) -&gt; decrease depth by 1\n * -&gt; increase \&quot;tolerance\&quot; by 1 (meaning we can tolerate -1 as a balance now)\n   # justification\n   # if balance was negative, we are treating it as a left paren\n   # if balance is positive at the end, we can treat it as a right paren.\n   # otherwise we can ignore it.\n\n \&quot;)(*\&quot;\n * -&gt; t = 1\n ) -&gt; d = -1 (implication: * is now &#39;(&#39;)\n ( -&gt; d = 0 (implication: * is now &#39;&#39;)\n\n Idea is, we \&quot;use up\&quot; tolerance if we ever go below positive depth.\n\n if d is invalid:\n   # use tolerance if possible, otherwise keep going, and convert tolerance\n   # to empty strings at the end.\n```\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;merge-two-sorted-linked-lists&quot;],&quot;date&quot;:[0,&quot;2026-01-07&quot;],&quot;problem&quot;:[0,&quot;merge-two-sorted-linked-lists&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;easy&quot;],&quot;time_minutes&quot;:[0,15],&quot;topics&quot;:[1,[[0,&quot;linked-list&quot;],[0,&quot;sorting&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nClassic merge algorithm, all you need to know is pointer manipulation. The dummy list head reduces edge cases.\nGot this one on the first try.\n\n## Solution\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:\n        head = ListNode(&#39;dummy&#39;)\n\n        cur = head\n\n        while list1 is not None and list2 is not None:\n            if list1.val &lt; list2.val:\n                cur.next = list1\n                list1 = list1.next\n                cur = cur.next\n            else:\n                cur.next = list2\n                list2 = list2.next\n                cur = cur.next\n        \n        while list1 is not None:\n            cur.next = list1\n            list1 = list1.next\n            cur = cur.next\n\n        while list2 is not None:\n            cur.next = list2\n            list2 = list2.next\n            cur = cur.next\n\n        return head.next\n\n```\n\n## Complexity\n\n* Time: O(n)\n* Space: O(n) (O(1) additional)\n\n## Results\n\nN/A\n\n## Next Steps\n\nShouldn&#39;t&#39;ve iterated through the linked list after the main merge, because appending the head automatically appends\nthe rest of the list. Meaning:\n\n```python\nwhile list1 is not None:\n    cur.next = list1\n    list1 = list1.next\n    cur = cur.next\n\nwhile list2 is not None:\n    cur.next = list2\n    list2 = list2.next\n    cur = cur.next\n```\n\nshould have been:\n\n```python\nif list1:\n    cur.next = list1\nelse:\n    cur.next = list2\n```\n\n## Notes\n\nNone.\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;first-missing-positive&quot;],&quot;date&quot;:[0,&quot;2026-01-06&quot;],&quot;problem&quot;:[0,&quot;first-missing-positive&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;hard&quot;],&quot;time_minutes&quot;:[0,30],&quot;topics&quot;:[1,[[0,&quot;array&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nThis&#39;ll be a terser explanation, due to time constraints.\n\nI started by doing the algorithm where you move each element to its corresponding sorted index,\nexcept that we would shift the range 1..n to 0..n-1. Then, since the first missing positive integer\nwould be the first mismatch, we&#39;d immediately find the solution upon iterating through the array.\n\nI started by moving each positive integer I encountered in the range 1..n to its corresponding index.\nIn order to preserve the set, I would move the integer in target index to the current position.\nI spent 2 incorrect answers debugging, before I realized that I wasn&#39;t replacing the new integer\nat the current position in case it was also in the range. This resulted in me missing certain\nswaps that needed to happen.\n\nBut this was sufficient to get the correct answer.\n\n## Solution\n\n```python\nclass Solution:\n    def firstMissingPositive(self, nums: List[int]) -&gt; int:\n        for i in range(len(nums)):\n            num = nums[i]\n            j = num-1\n\n            while num &gt;= 1 and num &lt;= len(nums) and nums[j] != num:\n                nums[i] = nums[j]\n                nums[j] = num\n                num = nums[i]\n                j = num-1\n\n        for i in range(len(nums)):\n            if nums[i] != i+1:\n                return i+1\n        return len(nums)+1\n\n```\n\n## Complexity\n\n* Time: O(n)\n  * justification: we rotate each subsequence at most once, which means that each element is\n    compared at most twice, which means a constant number of operations per element, or O(n)\n* Space: O(1) (auxiliary)\n  * justification: we never create an array, or create new elements in a loop. All modifications\n    happen in place, meaning that we use no extra space.\n\n## Results\n\nN/A (neetcode)\n\n## Next Steps\n\nFlesh out this explanation in more detail.\nSwitch to using binary search for the final step.\n\n## Notes\n\n\\[Any additional notes]\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;string-encode-and-decode&quot;],&quot;date&quot;:[0,&quot;2026-01-04&quot;],&quot;problem&quot;:[0,&quot;string-encode-and-decode&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,10],&quot;topics&quot;:[1,[[0,&quot;string&quot;],[0,&quot;design&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Problem\n\nDesign an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.\n\n## Approach\n\nFirst approach was to cheat a bit, just to see if it would work. `repr()` converts a python value to a\nstring that evaluates to the original value. Then, ast.literal\\_eval on the other side is the\n\&quot;inverse\&quot; of repr that definitely works for relatively simple things like lists of strings.\n\nHow does repr and ast.literal\\_eval encode values as python objects? Fundamentally, the core problem with\nany parsing task such as this is separating the data from the metadata. How do you know if something is\na value or not? That&#39;s done through program state. Roughly, here&#39;s the matrix:\n\n+---------------------+----------------------------------------------------------------------+------------------------------------------------------------+\n| Expecting \\ Actual  | Data                                                                 |  Metadata                                                  |\n+---------------------+----------------------------------------------------------------------+------------------------------------------------------------+\n| Data                | Normal parse                                                         |  dropped headers / fields; bad state, security risk likely |\n| Metadata            | Direct injection risk, very bad. User controls program control flow  |  Normal parse                                              |\n+---------------------+----------------------------------------------------------------------+------------------------------------------------------------+\n\nBecause we control both the encoder and the decoder, we can easily sync the initial state. We can either start with data/data,\nor metadata/metadata. How do we pick which is better?\n\nSuppose we chose our algorithm to start on data/data. Great. We start transmitting the string, one\ncharacter at a time. How do we know when the next string begins? We could emit a special character\nsequence, called a delimiter. but the problem is that the string itself could contain any possible\nascii sequence! That makes it impsosible to tell whether the delimiter represents the end of the\nstring, or is part of the string itself.\n\nHere, one possible approach is try to make this work by mapping some characters onto two character\nsequences -- we call this \&quot;escaping\&quot;. For instance, we could say that strings are null terminated,\nalways ending in `chr(0)`, or `&#39;\\0&#39;`. But then, what happens if `chr(0)` is in the string itself? Then,\nwe would escape, letting `\&quot;\\\\0\&quot;` represent the null terminator if it&#39;s in a string. But then what\nabout `&#39;\\&#39;` itself? Well, we would map that one to `&#39;\\\\&#39;`. Now, `&#39;\\&#39;` is a special character that determines\nhow the next character is processed, and `chr(0)` actually never appears directly in the strings\nthemselves.\n\nThis is complicated! Luckily, there is a simpler approach, which is what I used. If we switch to\nmetadata/metadata to start, we can include everything needed to process the first string right at\nthe beginning. If we prefix each string with its length, we can process the following data\nup to that length, before switching back to processing metadata. here&#39;s what I mean:\n\n```\n[\&quot;Hello\&quot;, \&quot;world\&quot;] -&gt; [5Hello5world]\n```\n\nDecoding, we read off the number at the start, process that many characters and append it to our list,\nwhich reverses the above.\n\nThere&#39;s some problems with this approach. How do we know when the number ends? What if\nthe string starts with a number, For instance, take the following cases:\n\n```\n[\&quot;verylongstring\&quot;, \&quot;wow\&quot;] -&gt; 14verylongstring3wow\n[\&quot;1337\&quot;, \&quot;speak\&quot;] -&gt; 413375speak\n```\n\nIn the first example, we read off multiple digits to handle a string over 9 characters. All&#39;s well and good,\nwe can just stop parsing after the first non-digit. But as soon as we try to implement that, the second\ncase bites us: we try to read a string of length 413375, not knowing that the first string actually\nconsists of the numbers \&quot;1337\&quot;.\n\nHere, we need only introduce a separator between the number and the string it represents. &#39;,&#39; works fine\n\\-- it unambiguously signals the end of the number.\n\nThis works and is the most flexible approach, but it&#39;s a bit annoying that the number spans multiple characters.\nSo, I noticed that the max string length was 200 &lt;= 255 = 2^8-1, the max size of a char, meaning we could use a\nsingle character to store the length.\n\nSo that&#39;s how my solution deviates. I use a single char/byte anyway, relying on the fact that strings are at most\n200 characters long. But even if we allowed infinite length strings, the previous approach still works.\n\nI also add a 255 as a control character to determine the end of the sequence. This is not required for the\nproblem, as we have the full string and can check if the string is empty. But in real network scenarios,\nwe might run into a situation where we are streaming data and it&#39;s not obvious that the data is finished.\nWhich is why I included that.\n\n## Solution\n\n```python\nclass Solution:\n\n    def encode(self, strs: List[str]) -&gt; str:\n        return &#39;&#39;.join(s for t in zip((chr(len(s)) for s in strs), strs) for s in t) + chr(255)\n\n    def decode(self, s: str) -&gt; List[str]:\n        res = []\n        while ord(s[0]) != 255:\n            l = ord(s[0])\n            res.append(s[1:l+1])\n            s = s[l+1:]\n        return res\n\n\n```\n\n## Complexity\n\n* Time: O(n)\n* Space: O(n)\n\n## Results\n\nN/A (neetcode)\n\n## Next Steps\n\nNeed to improve explanation. Should get better at talking and start recording self.\n\n## Notes\n\nNo notes this time. Straight to implementation.\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;top-k-frequent-elements&quot;],&quot;date&quot;:[0,&quot;2026-01-03&quot;],&quot;problem&quot;:[0,&quot;top-k-frequent-elements&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,15],&quot;topics&quot;:[1,[[0,&quot;array&quot;],[0,&quot;hash-map&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;This problem was harder than I expected, and it didn&#39;t occur to me immediately how to solve it,\nso I started checking hints (bad, I know). The key insight is that frequencies form a partition.\n\nOnce that was clear, it was easy to organize the collection by frequency, and then select off\nthe top k most frequent elements.\n\n## Problem\n\n&gt; Given an integer array nums and an integer k, return the k most frequent elements within the array.\n&gt; The test cases are generated so that the solution is unique.\n\n## Approach\n\nThe simplest solution would be to generate counts (with a dict), then convert to an array, and sort and\nextract the top k elements.\n\nThis solution works, but has a step that is O(nlogn) -- sorting the array.\n\nHow can we reduce this O(nlogn) step to O(n)? The key (no pun intended) is realizing that\nthe range of frequency values are bounded -- the highest possible frequency is n itself,\nbecause there are at most n elements in the array. It forms a partition.\n\nThat means that if we can somehow look up elements based on their frequency, we can\njust iterate from n down to 0, printing the first k elements we encounter.\n\nTherefore, we need only to maintain a grouping of elements by their frequency (which we can hold\nin an array because the key values are 0..n), which we can during the count, or after, all in\none shot. Here, I opted to construct it incrementally, but 3 passes might have been faster.\n\nAs promised, we select the top k elements, which is what the last statement does in a more\nfunctional style.\n\n## Solution\n\n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:\n        d = collections.defaultdict(int)\n        groups = [set(nums)] + [set() for _ in range(len(nums))]\n        for num in nums:\n            i = d[num]\n            d[num] += 1\n            groups[i].remove(num)\n            groups[i+1].add(num)\n        return [num for s in groups for num in s][-k:]\n\n```\n\n## Complexity\n\nTODO\n\n* Time: O(n)\n* Space: O(n)\n\n## Notes\n\nIt&#39;s not immediately obvious to me how to solve this one.\nAfter looking at hint 1 and 2, it says I&#39;m supposed to\ngroup numbers based on their frequency.\nit&#39;s also obvious that my solution should be O(n) time.\nIf we had a dictionary from frequency -&gt; set of values,\nThen I could start from the highest frequency and move down\nIterating through the range of frequency values could be expensive.\nActually, since the frequencies form a partition of n, the\nlength of the list, I have to through n -&gt; 0 to hit every\npossible frequency.\nAnd we could further optimize by using a list of sets\ninstead of a dictionary of sets. That would improve performance.\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;anagram-groups&quot;],&quot;date&quot;:[0,&quot;2026-01-02&quot;],&quot;problem&quot;:[0,&quot;anagram-groups&quot;],&quot;source&quot;:[0,&quot;neetcode&quot;],&quot;difficulty&quot;:[0,&quot;medium&quot;],&quot;time_minutes&quot;:[0,10],&quot;topics&quot;:[1,[[0,&quot;hash-map&quot;],[0,&quot;string&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nThis problem is mostly about clean implementation once you know that the best way to determine\nanagrams is by counting characters. There&#39;s the added wrinkle that your counts object is not\nhashable, which means it&#39;s hard to group strings based on them having the same counts. But\nthat&#39;s easy if you either use a frozenset, which allows you to hash non hashable types, or you\ndo what I did, and convert the unhashable type to a canonical string directly.\n\nI could have also used python Counters, to make it even easier, but I haven&#39;t fully memorized\nthe API so I thought it&#39;d be better if I stuck to less powerful approaches.\n\ncollections.defaultdict is very powerful though, and worth learning.\n\n## Solution\n\n```python\nclass Solution:\n    def countsToKey(self, d: dict) -&gt; str:\n        return &#39;,&#39;.join(str(d[chr(ord(&#39;a&#39;)+i)]) for i in range(26))\n\n    def strToCounts(self, s: str) -&gt; dict:\n        d = collections.defaultdict(int)\n        for c in s:\n            d[c] += 1\n        return d\n\n    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:\n        d = {}\n        for s in strs:\n            k = self.countsToKey(self.strToCounts(s))\n            if k not in d:\n                d[k] = []\n            d[k].append(s)\n        return list(d.values())\n\n```\n\n## Complexity\n\n* Time: O(n)\n* Space: O(n)\n\n## Results\n\nN/A (NeetCode)\n\n## Next Steps\n\nThere&#39;s a little bit of inconsistency with the APIs used, as I threw in\ncollections.defaultdict to fix a bug with key generation. Sticking to something simpler\ndespite the annoyance, or going all out with all the upgraded APIs, would probably be better.\n\nClaude suggested I used tuple() instead of string generation, for a few reasons:\n\n* Hashing — Tuples of ints hash directly. Strings require hashing each character, and your string is longer (commas, multi-digit numbers) than a 26-int tuple&#39;s logical content.\n* String building — &#39;,&#39;.join(...) creates intermediate strings and a generator. tuple(counts) on a list is a single C-level copy.\n* Memory — \&quot;0,0,0,3,0,...\&quot; takes more bytes than (0,0,0,3,0,...) since each digit is a character.\n\nWill try to remember tuples for future problems.\n\n## Notes\n\nN/A\n&quot;]}],[0,{&quot;slug&quot;:[0,&quot;n-queens&quot;],&quot;date&quot;:[0,&quot;2026-01-01&quot;],&quot;problem&quot;:[0,&quot;n-queens&quot;],&quot;source&quot;:[0,&quot;leetcode&quot;],&quot;difficulty&quot;:[0,&quot;hard&quot;],&quot;time_minutes&quot;:[0,90],&quot;topics&quot;:[1,[[0,&quot;backtracking&quot;]]],&quot;language&quot;:[0,&quot;python&quot;],&quot;markdown&quot;:[0,&quot;## Approach\n\nThis is a pretty standard backtracking problem. You generate all the possible boards, but save only the ones\nthat are valid. Halfway through, I generated some binary strings as practice:\n\n```python\ndef binaryStringsRec(l: int):\n    result = []\n    if l == 0:\n        result.append([])\n        return result\n    for c in [&#39;0&#39;, &#39;1&#39;]:\n        for s in binaryStringsRec(l-1):\n            result.append([c]+s)\n    return result\n\ndef binaryStrings(l=8):\n    return [&#39;&#39;.join(s) for s in binaryStringsRec(l)];\n```\n\nIn all backtracking problems, we need a way to generate correct partial results (that are correct),\nand progressively build them into full solutions. A binary string consists of 0 or 1 prepended to\na binary string. If length is a parameter, it determines our base case. In the n-queens problem,\na valid solutions is a board where no queens are attacking each other, and our base case is when\nthe number of queens is equal to the number of rows and columns on the board (because we can&#39;t\nplace more).\n\nIf we can swap out the logic in the recursive helper, by enumerating and combining board positions\ninstead of 0s or 1s, we&#39;d be well on our way to generating a correct solution.\n\nI started by thinking about my board representation. I decided to go with an unrolled list of length n\\*n,\nas in a matrix in row major order. The two primary advantages of this approach (as opposed to a list\nof lists) is that I need only one integer as my index, and that it makes cloning easier (via slicing).\nThen I started thinking of a way to generate queen moves from a queen position. It was easiest to\nthink of this in 2d, so I just created two small helpers to convert to and from a 2d index. And those\nhelpers gave me a nice opportunity to detect moves off the board as well, so I added that.\n\nThen, in an effort to simplify things further, I wrote markQueenMoves, and made it modify an existing\nboard instead of returning a new board. This allowed me to not worry about combining moves from two\nboards, as I might do if I were writing in a more functional style. This was a choice out of convenience.\n\nsolveNQueensRec is the meat of the logic. But that too isn&#39;t terribly complicated. You can&#39;t place a\nqueen on a covered square, and once you&#39;ve placed a queen, if it&#39;s your last queen, you&#39;re done, and\nif it&#39;s not, you place the current queen, and then call the function again to place the remaining\nqueens. We return an list because we&#39;re accumulating results, not just determining if a solution\nexists. naturally, an empty list corresponds to no solutions, which means we can combine lists using\nthe + operator, or via append / extend.\n\nsolveNQueens is just a wrapper for the recursive helper, and the signature required by the question.\n\nAfter testing on a 9x9 board, there was just one small wrinkle -- TLE. Turns out you can&#39;t enumerate\nEVERY possible queen position as it&#39;s too inefficient. There are three levels to the inefficiency:\n\n1. True (n^2)!/(n^2-n)! -- least efficient, but every possible enumeration counting duplicates\n2. (n^2)Cn -- easy if you constrain each queen to start after the one placed before it. Cuts down by a n! factor.\n3. Row-wise enumeration (just snuck me into passing). Force each queen to start on a new row, but\n   that&#39;s all. This leverages the fact that new queens should be on new rows, but there&#39;s probably\n   more optimizations you could make.\n\n## Complexity\n\n* Time: O(n^n)\n  Reason: We try every row and every column at most once\n* Space: O(?)\n  Not sure on this one. My initial thought was the number of active boards is proportional to the depth of\n  recursion, so O(n^3) because each board is O(n^2) and recursion depth is O(n). But if we count the solution\n  size, it gets more complicated and turns into a counting problem. An upper bound for it is O(n!n!)\n  (permutations of rows and columns) but that&#39;s also wildly overestimating the set of solutions that are\n  valid.\n\n## Results\n\n119ms (5.58th percentile)\n18.29MB (42.66%)\n\nNot good, but not bad for a first hard problem after being rusty.\n\n## Next Steps\n\nI intend to revisit this problem. I think an approach where you slot each queen into a row, column, and\ndiagonals, might lead to a faster solution.\n\n## Notes\n\n* pretty standard backtracking.\n* i&#39;m sure we could do some invariant stuff with eightfold symmetry, but let&#39;s keep it\n* simple to start.\n* brute force with backtracking.\n* We&#39;ll need a way to mark off squares that are covered.\n* We&#39;ll also need a way to mark off covered squares every time we place a queen.\n* We could use a boolean array from 1..n^2 for this.\n* but first we need a way to generate queen moves.\n&quot;]}]]],&quot;slug&quot;:[0,&quot;first-missing-positive&quot;]}" ssr client="load" opts="{&quot;name&quot;:&quot;ProblemDetail&quot;,&quot;value&quot;:true}" await-children><button class="theme-toggle" aria-label="Toggle theme">☀️</button><div class="problem-detail"><div class="problem-header"><a href="/leetcode-calendar/" class="back-link">← Back to Calendar</a></div><div class="problem-meta"><h1>first-missing-positive</h1><div class="problem-info"><span class="info-item">📅 <!-- -->January 6, 2026</span><span class="info-item">🔗 <!-- -->neetcode</span><span class="info-item difficulty-hard">hard</span><span class="info-item">⏱️ <!-- -->30<!-- --> minutes</span><span class="info-item">💻 <!-- -->python</span></div><div class="problem-topics"><span class="topic-tag">array</span></div></div><div class="problem-content markdown-body"><h2>Approach</h2>
<p>This&#x27;ll be a terser explanation, due to time constraints.</p>
<p>I started by doing the algorithm where you move each element to its corresponding sorted index,
except that we would shift the range 1..n to 0..n-1. Then, since the first missing positive integer
would be the first mismatch, we&#x27;d immediately find the solution upon iterating through the array.</p>
<p>I started by moving each positive integer I encountered in the range 1..n to its corresponding index.
In order to preserve the set, I would move the integer in target index to the current position.
I spent 2 incorrect answers debugging, before I realized that I wasn&#x27;t replacing the new integer
at the current position in case it was also in the range. This resulted in me missing certain
swaps that needed to happen.</p>
<p>But this was sufficient to get the correct answer.</p>
<h2>Solution</h2>
<pre><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">firstMissingPositive</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):
            num = nums[i]
            j = num-<span class="hljs-number">1</span>

            <span class="hljs-keyword">while</span> num &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> num &lt;= <span class="hljs-built_in">len</span>(nums) <span class="hljs-keyword">and</span> nums[j] != num:
                nums[i] = nums[j]
                nums[j] = num
                num = nums[i]
                j = num-<span class="hljs-number">1</span>

        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):
            <span class="hljs-keyword">if</span> nums[i] != i+<span class="hljs-number">1</span>:
                <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span>

</code></pre>
<h2>Complexity</h2>
<ul>
<li>Time: O(n)<!-- -->
<ul>
<li>justification: we rotate each subsequence at most once, which means that each element is
compared at most twice, which means a constant number of operations per element, or O(n)</li>
</ul>
</li>
<li>Space: O(1) (auxiliary)<!-- -->
<ul>
<li>justification: we never create an array, or create new elements in a loop. All modifications
happen in place, meaning that we use no extra space.</li>
</ul>
</li>
</ul>
<h2>Results</h2>
<p>N/A (neetcode)</p>
<h2>Next Steps</h2>
<p>Flesh out this explanation in more detail.
Switch to using binary search for the final step.</p>
<h2>Notes</h2>
<p>[Any additional notes]</p></div></div><!--astro:end--></astro-island>  </div> </body></html>