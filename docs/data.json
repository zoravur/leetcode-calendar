{
  "problems": [
    {
      "slug": "anagram-groups",
      "date": "2026-01-02",
      "problem": "anagram-groups",
      "source": "neetcode",
      "difficulty": "medium",
      "time_minutes": 10,
      "topics": [
        "hash-map",
        "string"
      ],
      "language": "python",
      "markdown": "\n## Approach\n\nThis problem is mostly about clean implementation once you know that the best way to determine\nanagrams is by counting characters. There's the added wrinkle that your counts object is not\nhashable, which means it's hard to group strings based on them having the same counts. But \nthat's easy if you either use a frozenset, which allows you to hash non hashable types, or you\ndo what I did, and convert the unhashable type to a canonical string directly.\n\nI could have also used python Counters, to make it even easier, but I haven't fully memorized \nthe API so I thought it'd be better if I stuck to less powerful approaches.\n\ncollections.defaultdict is very powerful though, and worth learning.\n\n## Complexity\n\n- Time: O(n)\n- Space: O(n)\n\n## Results\n\nN/A (NeetCode)\n\n## Next Steps\n\nThere's a little bit of inconsistency with the APIs used, as I threw in \ncollections.defaultdict to fix a bug with key generation. Sticking to something simpler \ndespite the annoyance, or going all out with all the upgraded APIs, would probably be better.\n\nClaude suggested I used tuple() instead of string generation, for a few reasons:\n- Hashing — Tuples of ints hash directly. Strings require hashing each character, and your string is longer (commas, multi-digit numbers) than a 26-int tuple's logical content.\n- String building — ','.join(...) creates intermediate strings and a generator. tuple(counts) on a list is a single C-level copy.\n- Memory — \"0,0,0,3,0,...\" takes more bytes than (0,0,0,3,0,...) since each digit is a character.\n\nWill try to remember tuples for future problems.\n\n## Notes\n\nN/A\n"
    },
    {
      "slug": "n-queens",
      "date": "2026-01-01",
      "problem": "n-queens",
      "source": "leetcode",
      "difficulty": "hard",
      "time_minutes": 90,
      "topics": [
        "backtracking"
      ],
      "language": "python",
      "markdown": "\n## Approach\n\nThis is a pretty standard backtracking problem. You generate all the possible boards, but save only the ones\nthat are valid. Halfway through, I generated some binary strings as practice:\n\n```python\ndef binaryStringsRec(l: int):\n    result = []\n    if l == 0:\n        result.append([])\n        return result\n    for c in ['0', '1']:\n        for s in binaryStringsRec(l-1):\n            result.append([c]+s)\n    return result\n\ndef binaryStrings(l=8):\n    return [''.join(s) for s in binaryStringsRec(l)];\n```\n\nIn all backtracking problems, we need a way to generate correct partial results (that are correct),\nand progressively build them into full solutions. A binary string consists of 0 or 1 prepended to \na binary string. If length is a parameter, it determines our base case. In the n-queens problem,\na valid solutions is a board where no queens are attacking each other, and our base case is when \nthe number of queens is equal to the number of rows and columns on the board (because we can't \nplace more).\n\nIf we can swap out the logic in the recursive helper, by enumerating and combining board positions \ninstead of 0s or 1s, we'd be well on our way to generating a correct solution.\n\nI started by thinking about my board representation. I decided to go with an unrolled list of length n*n,\nas in a matrix in row major order. The two primary advantages of this approach (as opposed to a list \nof lists) is that I need only one integer as my index, and that it makes cloning easier (via slicing).\nThen I started thinking of a way to generate queen moves from a queen position. It was easiest to\nthink of this in 2d, so I just created two small helpers to convert to and from a 2d index. And those\nhelpers gave me a nice opportunity to detect moves off the board as well, so I added that.\n\nThen, in an effort to simplify things further, I wrote markQueenMoves, and made it modify an existing\nboard instead of returning a new board. This allowed me to not worry about combining moves from two\nboards, as I might do if I were writing in a more functional style. This was a choice out of convenience.\n\nsolveNQueensRec is the meat of the logic. But that too isn't terribly complicated. You can't place a\nqueen on a covered square, and once you've placed a queen, if it's your last queen, you're done, and \nif it's not, you place the current queen, and then call the function again to place the remaining \nqueens. We return an list because we're accumulating results, not just determining if a solution \nexists. naturally, an empty list corresponds to no solutions, which means we can combine lists using\nthe + operator, or via append / extend.\n\nsolveNQueens is just a wrapper for the recursive helper, and the signature required by the question.\n\nAfter testing on a 9x9 board, there was just one small wrinkle -- TLE. Turns out you can't enumerate \nEVERY possible queen position as it's too inefficient. There are three levels to the inefficiency:\n1) True (n^2)!/(n^2-n)! -- least efficient, but every possible enumeration counting duplicates\n2) (n^2)Cn -- easy if you constrain each queen to start after the one placed before it. Cuts down by a n! factor.\n3) Row-wise enumeration (just snuck me into passing). Force each queen to start on a new row, but \n    that's all. This leverages the fact that new queens should be on new rows, but there's probably\n    more optimizations you could make.\n\n\n## Complexity\n\n- Time: O(n^n)\nReason: We try every row and every column at most once\n- Space: O(?)\nNot sure on this one. My initial thought was the number of active boards is proportional to the depth of \nrecursion, so O(n^3) because each board is O(n^2) and recursion depth is O(n). But if we count the solution\nsize, it gets more complicated and turns into a counting problem. An upper bound for it is O(n!n!) \n(permutations of rows and columns) but that's also wildly overestimating the set of solutions that are \nvalid.\n\n## Results\n\n119ms (5.58th percentile)\n18.29MB (42.66%)\n\nNot good, but not bad for a first hard problem after being rusty.\n\n## Next Steps\n\nI intend to revisit this problem. I think an approach where you slot each queen into a row, column, and \ndiagonals, might lead to a faster solution.\n\n## Notes\n- pretty standard backtracking.\n- i'm sure we could do some invariant stuff with eightfold symmetry, but let's keep it\n- simple to start.\n- brute force with backtracking.\n- We'll need a way to mark off squares that are covered.\n- We'll also need a way to mark off covered squares every time we place a queen.\n- We could use a boolean array from 1..n^2 for this.\n- but first we need a way to generate queen moves.\n\n\n"
    }
  ],
  "heatmapData": [
    {
      "date": "2025-12-31",
      "count": 0,
      "level": 0
    },
    {
      "date": "2026-01-01",
      "count": 1,
      "level": 4
    },
    {
      "date": "2026-01-02",
      "count": 1,
      "level": 4
    }
  ],
  "cumulativeData": {
    "dates": [
      "2026-01-01",
      "2026-01-02"
    ],
    "actual": [
      1,
      2
    ],
    "trend": [
      1,
      2
    ]
  }
}